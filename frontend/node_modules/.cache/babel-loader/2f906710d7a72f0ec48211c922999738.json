{"ast":null,"code":"import React from 'react'; // vector add\n\nfunction addV(v1, v2) {\n  return v1.map(function (v, i) {\n    return v + v2[i];\n  });\n} // vector substract\n\n\nfunction subV(v1, v2) {\n  return v1.map(function (v, i) {\n    return v - v2[i];\n  });\n}\n/**\r\n * Calculates velocity\r\n * @param delta the difference between current and previous vectors\r\n * @param delta_t the time offset\r\n * @param len the length of the delta vector\r\n * @returns velocity\r\n */\n\n\nfunction calculateVelocity(delta, delta_t, len) {\n  len = len || Math.hypot.apply(Math, delta);\n  return delta_t ? len / delta_t : 0;\n}\n/**\r\n * Calculates velocities vector\r\n * @template T the expected vector type\r\n * @param delta the difference between current and previous vectors\r\n * @param delta_t the time offset\r\n * @returns velocities vector\r\n */\n\n\nfunction calculateVelocities(delta, delta_t) {\n  return delta_t ? delta.map(function (v) {\n    return v / delta_t;\n  }) : Array(delta.length).fill(0);\n}\n/**\r\n * Calculates distance\r\n * @param movement the difference between current and initial vectors\r\n * @returns distance\r\n */\n\n\nfunction calculateDistance(movement) {\n  return Math.hypot.apply(Math, movement);\n}\n/**\r\n * Calculates direction\r\n * @template T the expected vector type\r\n * @param delta\r\n * @param len\r\n * @returns direction\r\n */\n\n\nfunction calculateDirection(delta, len) {\n  len = len || Math.hypot.apply(Math, delta) || 1;\n  return delta.map(function (v) {\n    return v / len;\n  });\n}\n/**\r\n * Calculates all kinematics\r\n * @template T the expected vector type\r\n * @param movement the difference between current and initial vectors\r\n * @param delta the difference between current and previous vectors\r\n * @param delta_t the time difference between current and previous timestamps\r\n * @returns all kinematics\r\n */\n\n\nfunction calculateAllKinematics(movement, delta, delta_t) {\n  var len = Math.hypot.apply(Math, delta);\n  return {\n    velocities: calculateVelocities(delta, delta_t),\n    velocity: calculateVelocity(delta, delta_t, len),\n    distance: calculateDistance(movement),\n    direction: calculateDirection(delta, len)\n  };\n}\n\nfunction getIntentional(movement, threshold) {\n  var abs = Math.abs(movement);\n  return abs >= threshold ? Math.sign(movement) * threshold : false;\n}\n\nfunction minMax(value, min, max) {\n  return Math.max(min, Math.min(value, max));\n} // Based on @aholachek ;)\n// https://twitter.com/chpwn/status/285540192096497664\n// iOS constant = 0.55\n// https://medium.com/@nathangitter/building-fluid-interfaces-ios-swift-9732bb934bf5\n\n\nfunction rubberband2(distance, constant) {\n  // default constant from the article is 0.7\n  return Math.pow(distance, constant * 5);\n}\n\nfunction rubberband(distance, dimension, constant) {\n  if (dimension === 0 || Math.abs(dimension) === Infinity) return rubberband2(distance, constant);\n  return distance * dimension * constant / (dimension + constant * distance);\n}\n\nfunction rubberbandIfOutOfBounds(position, min, max, constant) {\n  if (constant === void 0) {\n    constant = 0.15;\n  }\n\n  if (constant === 0) return minMax(position, min, max);\n\n  if (position < min) {\n    return -rubberband(min - position, max - min, constant) + min;\n  }\n\n  if (position > max) {\n    return rubberband(position - max, max - min, constant) + max;\n  }\n\n  return position;\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n} // blank function\n\n\nfunction noop() {} // returns a function that chains all functions given as parameters\n\n\nvar chainFns = function chainFns() {\n  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {\n    fns[_key] = arguments[_key];\n  }\n\n  return function () {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    return fns.forEach(function (fn) {\n      return fn.apply(void 0, args);\n    });\n  };\n};\n\nvar def = {\n  array: function array(value) {\n    return Array.isArray(value) ? value : [value, value];\n  },\n  withDefault: function withDefault(value, defaultIfUndefined) {\n    return value !== void 0 ? value : defaultIfUndefined;\n  }\n};\n\nfunction matchKeysFromObject(obj, matchingObject) {\n  var o = {};\n  Object.entries(obj).forEach(function (_ref) {\n    var key = _ref[0],\n        value = _ref[1];\n    return (value !== void 0 || key in matchingObject) && (o[key] = value);\n  });\n  return o;\n}\n\nfunction valueFn(v) {\n  return typeof v === 'function' ? v() : v;\n}\n\nfunction getInitialState() {\n  // common initial state for all gestures\n  var initialCommon = {\n    _active: false,\n    _blocked: false,\n    _intentional: [false, false],\n    _movement: [0, 0],\n    _initial: [0, 0],\n    event: undefined,\n    // currentTarget: undefined,\n    // pointerId: undefined,\n    values: [0, 0],\n    velocities: [0, 0],\n    delta: [0, 0],\n    movement: [0, 0],\n    offset: [0, 0],\n    lastOffset: [0, 0],\n    direction: [0, 0],\n    initial: [0, 0],\n    previous: [0, 0],\n    first: false,\n    last: false,\n    active: false,\n    timeStamp: 0,\n    startTime: 0,\n    elapsedTime: 0,\n    cancel: noop,\n    canceled: false,\n    memo: undefined,\n    args: undefined\n  }; // initial state for coordinates-based gestures\n\n  var initialCoordinates = {\n    axis: undefined,\n    xy: [0, 0],\n    vxvy: [0, 0],\n    velocity: 0,\n    distance: 0\n  }; // initial state for distance and angle-based gestures (pinch)\n\n  var initialDistanceAngle = {\n    da: [0, 0],\n    vdva: [0, 0],\n    origin: undefined,\n    turns: 0\n  }; // initial state object (used by the gesture controller)\n\n  return {\n    shared: {\n      hovering: false,\n      scrolling: false,\n      wheeling: false,\n      dragging: false,\n      moving: false,\n      pinching: false,\n      touches: 0,\n      buttons: 0,\n      down: false,\n      shiftKey: false,\n      altKey: false,\n      metaKey: false,\n      ctrlKey: false\n    },\n    drag: _extends({}, initialCommon, {}, initialCoordinates, {\n      _isTap: true,\n      _delayedEvent: false,\n      tap: false,\n      swipe: [0, 0]\n    }),\n    pinch: _extends({}, initialCommon, {}, initialDistanceAngle),\n    wheel: _extends({}, initialCommon, {}, initialCoordinates),\n    move: _extends({}, initialCommon, {}, initialCoordinates),\n    scroll: _extends({}, initialCommon, {}, initialCoordinates)\n  };\n}\n\nvar setListeners = function setListeners(add) {\n  return function (el, listeners, options) {\n    var action = add ? 'addEventListener' : 'removeEventListener';\n    listeners.forEach(function (_ref) {\n      var eventName = _ref[0],\n          fn = _ref[1];\n      return el[action](eventName, fn, options);\n    });\n  };\n};\n/**\r\n * Whether the browser supports GestureEvent (ie Safari)\r\n * @returns true if the browser supports gesture event\r\n */\n\n\nfunction supportsGestureEvents() {\n  try {\n    // TODO [TS] possibly find GestureEvent definitions?\n    // @ts-ignore: no type definitions for webkit GestureEvents\n    return 'constructor' in GestureEvent;\n  } catch (e) {\n    return false;\n  }\n}\n\nvar addListeners =\n/*#__PURE__*/\nsetListeners(true);\nvar removeListeners =\n/*#__PURE__*/\nsetListeners(false);\n/**\r\n * Gets modifier keys from event\r\n * @param event\r\n * @returns modifier keys\r\n */\n\nfunction getModifierKeys(event) {\n  var shiftKey = event.shiftKey,\n      altKey = event.altKey,\n      metaKey = event.metaKey,\n      ctrlKey = event.ctrlKey;\n  return {\n    shiftKey: shiftKey,\n    altKey: altKey,\n    metaKey: metaKey,\n    ctrlKey: ctrlKey\n  };\n}\n\nfunction getTouchEvents(event) {\n  if ('touches' in event) {\n    var touches = event.touches,\n        changedTouches = event.changedTouches;\n    return touches.length > 0 ? touches : changedTouches;\n  }\n\n  return null;\n}\n\nfunction getGenericEventData(event) {\n  var buttons = 'buttons' in event ? event.buttons : 0;\n  var touchEvents = getTouchEvents(event);\n  var touches = touchEvents && touchEvents.length || 0;\n  var down = touches > 0 || buttons > 0;\n  return _extends({\n    touches: touches,\n    down: down,\n    buttons: buttons\n  }, getModifierKeys(event));\n}\n/**\r\n * Gets scroll event values\r\n * @param event\r\n * @returns scroll event values\r\n */\n\n\nfunction getScrollEventValues(event) {\n  // If the currentTarget is the window then we return the scrollX/Y position.\n  // If not (ie the currentTarget is a DOM element), then we return scrollLeft/Top\n  var _event$currentTarget = event.currentTarget,\n      scrollX = _event$currentTarget.scrollX,\n      scrollY = _event$currentTarget.scrollY,\n      scrollLeft = _event$currentTarget.scrollLeft,\n      scrollTop = _event$currentTarget.scrollTop;\n  return {\n    values: [scrollX || scrollLeft || 0, scrollY || scrollTop || 0]\n  };\n}\n/**\r\n * Gets wheel event values.\r\n * @param event\r\n * @returns wheel event values\r\n */\n\n\nfunction getWheelEventValues(event) {\n  var deltaX = event.deltaX,\n      deltaY = event.deltaY; //TODO implement polyfill ?\n  // https://developer.mozilla.org/en-US/docs/Web/Events/wheel#Polyfill\n\n  return {\n    values: [deltaX, deltaY]\n  };\n}\n/**\r\n * Gets pointer event values.\r\n * @param event\r\n * @returns pointer event values\r\n */\n\n\nfunction getPointerEventValues(event) {\n  var touchEvents = getTouchEvents(event);\n\n  var _ref2 = touchEvents ? touchEvents[0] : event,\n      clientX = _ref2.clientX,\n      clientY = _ref2.clientY;\n\n  return {\n    values: [clientX, clientY]\n  };\n}\n\nvar WEBKIT_DISTANCE_SCALE_FACTOR = 260;\n/**\r\n * Gets webkit gesture event values.\r\n * @param event\r\n * @returns webkit gesture event values\r\n */\n\nfunction getWebkitGestureEventValues(event) {\n  return {\n    values: [event.scale * WEBKIT_DISTANCE_SCALE_FACTOR, event.rotation]\n  };\n}\n/**\r\n * Gets two touches event data\r\n * @param event\r\n * @returns two touches event data\r\n */\n\n\nfunction getTwoTouchesEventData(event) {\n  var touches = event.touches;\n  var dx = touches[1].clientX - touches[0].clientX;\n  var dy = touches[1].clientY - touches[0].clientY;\n  var values = [Math.hypot(dx, dy), -(Math.atan2(dx, dy) * 180) / Math.PI];\n  var origin = [(touches[1].clientX + touches[0].clientX) / 2, (touches[1].clientY + touches[0].clientY) / 2];\n  return {\n    values: values,\n    origin: origin\n  };\n}\n/**\r\n * The controller will keep track of the state for all gestures and also keep\r\n * track of timeouts, and window listeners.\r\n *\r\n * @template BinderType the type the bind function should return\r\n */\n\n\nvar Controller = function Controller() {\n  var _this = this;\n\n  this.state = getInitialState(); // state for all gestures\n\n  this.timeouts = {}; // keeping track of timeouts for debounced gestures (such as move, scroll, wheel)\n\n  this.domListeners = []; // when config.domTarget is set, we attach events directly to the dom\n\n  this.windowListeners = {}; // keeps track of window listeners added by gestures (drag only at the moment)\n\n  this.bindings = {}; // an object holding the handlers associated to the gestures\n\n  /**\r\n   * Function ran on component unmount: cleans timeouts and removes dom listeners set by the bind function.\r\n   */\n\n  this.clean = function () {\n    _this.resetBindings();\n\n    Object.values(_this.timeouts).forEach(clearTimeout);\n    Object.keys(_this.windowListeners).forEach(function (stateKey) {\n      return _this.removeWindowListeners(stateKey);\n    });\n  };\n  /**\r\n   * Function run every time the bind function is run (ie on every render).\r\n   * Resets the binding object and remove dom listeners attached to config.domTarget\r\n   */\n\n\n  this.resetBindings = function () {\n    _this.bindings = {};\n\n    var domTarget = _this.getDomTarget();\n\n    if (domTarget) {\n      removeListeners(domTarget, _this.domListeners, _this.config.eventOptions);\n      _this.domListeners = [];\n    }\n  };\n  /**\r\n   * Returns the domTarget element and parses a ref if needed.\r\n   */\n\n\n  this.getDomTarget = function () {\n    var domTarget = _this.config.domTarget;\n    return domTarget && 'current' in domTarget ? domTarget.current : domTarget;\n  };\n  /**\r\n   * Commodity function to let recognizers simply add listeners to config.window.\r\n   */\n\n\n  this.addWindowListeners = function (stateKey, listeners) {\n    if (!_this.config.window) return; // we use this.windowListeners to keep track of the listeners we add\n\n    _this.windowListeners[stateKey] = listeners;\n    addListeners(_this.config.window, listeners, _this.config.eventOptions);\n  };\n  /**\r\n   * Commodity function to let recognizers simply remove listeners to config.window.\r\n   */\n\n\n  this.removeWindowListeners = function (stateKey) {\n    if (!_this.config.window) return;\n    var listeners = _this.windowListeners[stateKey];\n\n    if (listeners) {\n      removeListeners(_this.config.window, listeners, _this.config.eventOptions);\n      delete _this.windowListeners[stateKey];\n    }\n  };\n  /**\r\n   * When config.domTarget is set, this function will add dom listeners to it\r\n   */\n\n\n  this.addDomTargetListeners = function (target) {\n    /** We iterate on the entries of this.binding for each event, then we chain\r\n     * the array of functions mapped to it and push them to this.domListeners\r\n     */\n    Object.entries(_this.bindings).forEach(function (_ref) {\n      var event = _ref[0],\n          fns = _ref[1];\n\n      _this.domListeners.push([event.substr(2).toLowerCase(), chainFns.apply(void 0, fns)]);\n    });\n    addListeners(target, _this.domListeners, _this.config.eventOptions);\n  };\n  /**\r\n   * this.bindings is an object which keys match ReactEventHandlerKeys.\r\n   * Since a recognizer might want to bind a handler function to an event key already used by a previously\r\n   * added recognizer, we need to make sure that each event key is an array of all the functions mapped for\r\n   * that key.\r\n   */\n\n\n  this.addBindings = function (eventNames, fn) {\n    var eventNamesArray = !Array.isArray(eventNames) ? [eventNames] : eventNames;\n    eventNamesArray.forEach(function (eventName) {\n      if (_this.bindings[eventName]) _this.bindings[eventName].push(fn);else _this.bindings[eventName] = [fn];\n    });\n  };\n  /**\r\n   * getBindings will return an object that will be bound by users\r\n   * to the react component they want to interact with.\r\n   */\n\n\n  this.getBindings = function () {\n    var bindings = {};\n    var captureString = _this.config.captureString;\n    Object.entries(_this.bindings).forEach(function (_ref2) {\n      var event = _ref2[0],\n          fns = _ref2[1];\n      var fnsArray = Array.isArray(fns) ? fns : [fns];\n      var key = event + captureString;\n      bindings[key] = chainFns.apply(void 0, fnsArray);\n    });\n    return bindings;\n  };\n\n  this.getBind = function () {\n    // If config.domTarget is set we add event listeners to it and return the clean function.\n    if (_this.config.domTarget) {\n      var domTarget = _this.getDomTarget();\n\n      domTarget && _this.addDomTargetListeners(domTarget);\n      return _this.clean;\n    } // If not, we return an object that contains gesture handlers mapped to react handler event keys.\n\n\n    return _this.getBindings();\n  };\n};\n/**\r\n * @private\r\n *\r\n * Utility hook called by all gesture hooks and that will be responsible for the internals.\r\n *\r\n * @param {Partial<InternalHandlers>} handlers\r\n * @param {RecognizerClasses} classes\r\n * @param {InternalConfig} config\r\n * @param {NativeHandlersPartial} nativeHandlers - native handlers such as onClick, onMouseDown, etc.\r\n * @returns {(...args: any[]) => HookReturnType<Config>}\r\n */\n\n\nfunction useRecognizers(handlers, classes, config, nativeHandlers) {\n  var controller = React.useRef(); // The gesture controller keeping track of all gesture states\n\n  var nativeRefs = React.useRef();\n\n  if (!controller.current) {\n    // We only initialize the gesture controller once\n    controller.current = new Controller();\n  } // We reassign the config and handlers to the controller on every render.\n\n\n  controller.current.config = config;\n  controller.current.handlers = handlers;\n  /**\r\n   * We also assign nativeHandlers to a ref, otherwise it they won't be refreshed\r\n   * on the next render.\r\n   */\n\n  nativeRefs.current = nativeHandlers;\n  /**\r\n   * When the component unmounts, we run the controller clean functions that will be responsible\r\n   * for removing listeners, clearing timeouts etc.\r\n   */\n\n  React.useEffect(function () {\n    return controller.current.clean;\n  }, []);\n  /**\r\n   * The bind function will create gesture recognizers and return the right\r\n   * bind object depending on whether `domTarget` was specified in the config object.\r\n   */\n\n  var _React$useState = React.useState(function () {\n    return function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      controller.current.resetBindings();\n      classes.forEach(function (RecognizerClass) {\n        var recognizer = new RecognizerClass(controller.current, args);\n        recognizer.addBindings();\n      });\n\n      if (nativeRefs.current) {\n        // we also add event bindings for native handlers\n        Object.entries(nativeRefs.current).forEach(function (_ref) {\n          var eventName = _ref[0],\n              fn = _ref[1]; // we're cheating when it comes to event type :(\n\n          controller.current.addBindings(eventName, fn);\n        });\n      }\n\n      return controller.current.getBind();\n    };\n  }),\n      bind = _React$useState[0];\n\n  return bind;\n}\n/**\r\n * @private\r\n * Recognizer abstract class.\r\n *\r\n * @protected\r\n * @abstract\r\n * @type {StateKey<T>} whether the Recognizer should deal with coordinates or distance / angle\r\n */\n\n\nvar Recognizer =\n/*#__PURE__*/\nfunction () {\n  /**\r\n   * Creates an instance of a gesture recognizer.\r\n   * @param stateKey drag, move, pinch, etc.\r\n   * @param controller the controller attached to the gesture\r\n   * @param [args] the args that should be passed to the gesture handler\r\n   */\n  function Recognizer(stateKey, controller, args) {\n    var _this = this;\n\n    if (args === void 0) {\n      args = [];\n    }\n\n    this.stateKey = stateKey;\n    this.controller = controller;\n    this.args = args; // Convenience method to set a timeout for a given gesture\n\n    this.setTimeout = function (callback, ms) {\n      var _window;\n\n      if (ms === void 0) {\n        ms = 140;\n      }\n\n      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n        args[_key - 2] = arguments[_key];\n      }\n\n      _this.controller.timeouts[_this.stateKey] = (_window = window).setTimeout.apply(_window, [callback, ms].concat(args));\n    }; // Convenience method to clear a timeout for a given gesture\n\n\n    this.clearTimeout = function () {\n      clearTimeout(_this.controller.timeouts[_this.stateKey]);\n    }; // Convenience method to add window listeners for a given gesture\n\n\n    this.addWindowListeners = function (listeners) {\n      _this.controller.addWindowListeners(_this.stateKey, listeners);\n    }; // Convenience method to remove window listeners for a given gesture\n\n\n    this.removeWindowListeners = function () {\n      _this.controller.removeWindowListeners(_this.stateKey);\n    };\n    /**\r\n     * Returns the reinitialized start state for the gesture.\r\n     * Should be common to all gestures.\r\n     *\r\n     * @param {Vector2} values\r\n     * @param {UseGestureEvent} event\r\n     * @returns - the start state for the gesture\r\n     */\n\n\n    this.getStartGestureState = function (values, event) {\n      return _extends({}, getInitialState()[_this.stateKey], {\n        _active: true,\n        values: values,\n        initial: values,\n        offset: _this.state.offset,\n        lastOffset: _this.state.offset,\n        startTime: event.timeStamp\n      });\n    }; // Runs rubberband on a vector\n\n\n    this.rubberband = function (vector, rubberband) {\n      var bounds = _this.config.bounds;\n      /**\r\n       * [x, y]: [rubberband(x, min, max), rubberband(y, min, max)]\r\n       */\n\n      return vector.map(function (v, i) {\n        return rubberbandIfOutOfBounds(v, bounds[i][0], bounds[i][1], rubberband[i]);\n      });\n    };\n    /**\r\n     * Fires the gesture handler\r\n     *\r\n     * @param {boolean} [forceFlag] - if true, then the handler will fire even if the gesture is not intentional\r\n     */\n\n\n    this.fireGestureHandler = function (forceFlag) {\n      /**\r\n       * If the gesture has been blocked (this can happen when the gesture has started in an unwanted direction),\r\n       * clean everything and don't do anything.\r\n       */\n      if (_this.state._blocked) {\n        _this.state._active = false;\n\n        _this.clean();\n\n        return null;\n      } // If the gesture has no intentional dimension, don't do fire the handler.\n\n\n      var _this$state$_intentio = _this.state._intentional,\n          intentionalX = _this$state$_intentio[0],\n          intentionalY = _this$state$_intentio[1];\n      if (!forceFlag && intentionalX === false && intentionalY === false) return null;\n      var _this$state = _this.state,\n          _active = _this$state._active,\n          active = _this$state.active;\n      _this.state.active = _active;\n      _this.state.first = _active && !active; // `first` is true when the gesture becomes active\n\n      _this.state.last = !_active; // `last` is true when the gesture becomes inactive\n\n      _this.controller.state.shared[_this.ingKey] = _active; // Sets dragging, pinching, etc. to the gesture active state\n\n      var state = _extends({}, _this.controller.state.shared, {}, _this.state, {}, _this.mapStateValues(_this.state)); // @ts-ignore\n\n\n      var newMemo = _this.handler(state); // Sets memo to the returned value of the handler (unless it's not undefined)\n\n\n      _this.state.memo = newMemo !== void 0 ? newMemo : _this.state.memo; // Cleans the gesture when the gesture is no longer active.\n\n      if (!_active) _this.clean();\n      return state;\n    };\n  } // Returns the gesture config\n\n\n  var _proto = Recognizer.prototype; // Conveninence method to update the shared state\n\n  _proto.updateSharedState = function updateSharedState(sharedState) {\n    Object.assign(this.controller.state.shared, sharedState);\n  } // Conveninence method to update the gesture state\n  ;\n\n  _proto.updateGestureState = function updateGestureState(gestureState) {\n    Object.assign(this.state, gestureState);\n  }\n  /**\r\n   * Returns a generic, common payload for all gestures from an event.\r\n   *\r\n   * @param {UseGestureEvent} event\r\n   * @param {boolean} [isStartEvent]\r\n   * @returns - the generic gesture payload\r\n   */\n  ;\n\n  _proto.getGenericPayload = function getGenericPayload(event, isStartEvent) {\n    var timeStamp = event.timeStamp;\n    var _this$state2 = this.state,\n        values = _this$state2.values,\n        startTime = _this$state2.startTime;\n    return {\n      event: event,\n      timeStamp: timeStamp,\n      elapsedTime: isStartEvent ? 0 : timeStamp - startTime,\n      args: this.args,\n      previous: values\n    };\n  }\n  /**\r\n   * Returns state properties depending on the movement and state.\r\n   *\r\n   * Should be overriden for custom behavior, doesn't do anything in the implementation\r\n   * below.\r\n   */\n  ;\n\n  _proto.checkIntentionality = function checkIntentionality(_intentional, _movement, _state) {\n    return {\n      _intentional: _intentional,\n      _blocked: false\n    };\n  }\n  /**\r\n   * Returns basic movement properties for the gesture based on the next values and current state.\r\n   */\n  ;\n\n  _proto.getMovement = function getMovement(values, state) {\n    if (state === void 0) {\n      state = this.state;\n    }\n\n    var _this$config = this.config,\n        initial = _this$config.initial,\n        threshold = _this$config.threshold,\n        rubberband = _this$config.rubberband;\n    var t0 = threshold[0],\n        t1 = threshold[1];\n    var _state2 = state,\n        _initial = _state2._initial,\n        _active = _state2._active,\n        intentional = _state2._intentional,\n        lastOffset = _state2.lastOffset,\n        prevMovement = _state2.movement;\n    var i0 = intentional[0],\n        i1 = intentional[1];\n\n    var _this$getInternalMove = this.getInternalMovement(values, state),\n        _m0 = _this$getInternalMove[0],\n        _m1 = _this$getInternalMove[1];\n    /**\r\n     * For both dimensions of the gesture, check its intentionality on each frame.\r\n     */\n\n\n    if (i0 === false) {\n      i0 = getIntentional(_m0, t0);\n    }\n\n    if (i1 === false) {\n      i1 = getIntentional(_m1, t1);\n    } // Get gesture specific state properties based on intentionality and movement.\n\n\n    var intentionalityCheck = this.checkIntentionality([i0, i1], [_m0, _m1], state);\n    var _intentional = intentionalityCheck._intentional,\n        _blocked = intentionalityCheck._blocked;\n    var _i0 = _intentional[0],\n        _i1 = _intentional[1];\n    var _movement = [_m0, _m1];\n    if (_i0 !== false && intentional[0] === false) _initial[0] = valueFn(initial)[0];\n    if (_i1 !== false && intentional[1] === false) _initial[1] = valueFn(initial)[1];\n    /**\r\n     * If the gesture has been blocked (from gesture specific checkIntentionality),\r\n     * stop right there.\r\n     */\n\n    if (_blocked) return _extends({}, intentionalityCheck, {\n      _movement: _movement\n    });\n    /**\r\n     * The movement sent to the handler has 0 in its dimensions when intentionality is false.\r\n     * It is calculated from the actual movement minus the threshold.\r\n     */\n\n    var movement = [_i0 !== false ? _m0 - _i0 : valueFn(initial)[0], _i1 !== false ? _m1 - _i1 : valueFn(initial)[1]];\n    var offset = addV(movement, lastOffset);\n    /**\r\n     * Rubberband should be 0 when the gesture is no longer active, so that movement\r\n     * and offset can return within their bounds.\r\n     */\n\n    var _rubberband = _active ? rubberband : [0, 0];\n\n    movement = this.rubberband(addV(movement, _initial), _rubberband); // rubberbanded movement\n\n    return _extends({}, intentionalityCheck, {\n      _initial: _initial,\n      _movement: _movement,\n      movement: movement,\n      offset: this.rubberband(offset, _rubberband),\n      delta: subV(movement, prevMovement)\n    });\n  } // Cleans the gesture. Can be overriden by gestures.\n  ;\n\n  _proto.clean = function clean() {\n    this.clearTimeout();\n    this.removeWindowListeners();\n  };\n\n  _createClass(Recognizer, [{\n    key: \"config\",\n    get: function get() {\n      return this.controller.config[this.stateKey];\n    } // Is the gesture enabled\n\n  }, {\n    key: \"enabled\",\n    get: function get() {\n      return this.controller.config.enabled && this.config.enabled;\n    } // Returns the controller state for a given gesture\n\n  }, {\n    key: \"state\",\n    get: function get() {\n      return this.controller.state[this.stateKey];\n    } // Returns the gesture handler\n\n  }, {\n    key: \"handler\",\n    get: function get() {\n      return this.controller.handlers[this.stateKey];\n    }\n  }]);\n\n  return Recognizer;\n}();\n/**\r\n * @private\r\n * Abstract class for coordinates-based gesture recongizers\r\n * @abstract\r\n * @class CoordinatesRecognizer\r\n * @extends {Recognizer<T>}\r\n * @template T\r\n */\n\n\nvar CoordinatesRecognizer =\n/*#__PURE__*/\nfunction (_Recognizer) {\n  _inheritsLoose(CoordinatesRecognizer, _Recognizer);\n\n  function CoordinatesRecognizer() {\n    return _Recognizer.apply(this, arguments) || this;\n  }\n\n  var _proto = CoordinatesRecognizer.prototype;\n  /**\r\n   * Returns the real movement (without taking intentionality into acount)\r\n   */\n\n  _proto.getInternalMovement = function getInternalMovement(values, state) {\n    return subV(values, state.initial);\n  }\n  /**\r\n   * In coordinates-based gesture, this function will detect the first intentional axis,\r\n   * lock the gesture axis if lockDirection is specified in the config, block the gesture\r\n   * if the first intentional axis doesn't match the specified axis in config.\r\n   *\r\n   * @param {[FalseOrNumber, FalseOrNumber]} _intentional\r\n   * @param {Vector2} _movement\r\n   * @param {PartialGestureState<T>} state\r\n   */\n  ;\n\n  _proto.checkIntentionality = function checkIntentionality(_intentional, _movement, state) {\n    var _intentional2 = _intentional,\n        _ix = _intentional2[0],\n        _iy = _intentional2[1];\n    var intentionalMovement = _ix !== false || _iy !== false;\n    var axis = state.axis;\n    var _blocked = false; // If the movement is intentional, we can compute axis.\n\n    if (intentionalMovement) {\n      var _movement$map = _movement.map(Math.abs),\n          absX = _movement$map[0],\n          absY = _movement$map[1];\n\n      var _this$config = this.config,\n          configAxis = _this$config.axis,\n          lockDirection = _this$config.lockDirection; // We make sure we only set axis value if it hadn't been detected before.\n\n      axis = axis || (absX > absY ? 'x' : absX < absY ? 'y' : undefined);\n\n      if (!!configAxis || lockDirection) {\n        if (!!axis) {\n          // If the detected axis doesn't match the config axis we block the gesture\n          if (!!configAxis && axis !== configAxis) _blocked = true;else {\n            // Otherwise we prevent the gesture from updating the unwanted axis.\n            var lockedIndex = axis === 'x' ? 1 : 0;\n            _intentional[lockedIndex] = false;\n          }\n        } else {\n          // Until we've detected the axis, we prevent the hnadler from updating.\n          _intentional = [false, false];\n        }\n      }\n    }\n\n    return {\n      _intentional: _intentional,\n      _blocked: _blocked,\n      axis: axis\n    };\n  };\n\n  _proto.getKinematics = function getKinematics(values, event) {\n    var timeStamp = this.state.timeStamp;\n    var movementDetection = this.getMovement(values, this.state);\n    var _blocked = movementDetection._blocked,\n        delta = movementDetection.delta,\n        movement = movementDetection.movement;\n    if (_blocked) return movementDetection;\n    var delta_t = event.timeStamp - timeStamp;\n    var kinematics = calculateAllKinematics(movement, delta, delta_t);\n    return _extends({\n      values: values,\n      delta: delta\n    }, movementDetection, {}, kinematics);\n  };\n\n  _proto.mapStateValues = function mapStateValues(state) {\n    return {\n      xy: state.values,\n      vxvy: state.velocities\n    };\n  };\n\n  return CoordinatesRecognizer;\n}(Recognizer);\n\nvar TAP_DISTANCE_THRESHOLD = 3;\nvar SWIPE_MAX_ELAPSED_TIME = 220;\n\nvar DragRecognizer =\n/*#__PURE__*/\nfunction (_CoordinatesRecognize) {\n  _inheritsLoose(DragRecognizer, _CoordinatesRecognize);\n\n  function DragRecognizer(controller, args) {\n    var _this;\n\n    _this = _CoordinatesRecognize.call(this, 'drag', controller, args) || this;\n    _this.ingKey = 'dragging';\n\n    _this.dragShouldStart = function (event) {\n      var _getGenericEventData = getGenericEventData(event),\n          touches = _getGenericEventData.touches;\n\n      return _this.enabled && touches < 2;\n    };\n\n    _this.setPointers = function (event) {\n      var currentTarget = event.currentTarget,\n          pointerId = event.pointerId; // @ts-ignore\n\n      if (currentTarget) currentTarget.setPointerCapture(pointerId);\n\n      _this.updateGestureState({\n        currentTarget: currentTarget,\n        pointerId: pointerId\n      });\n    };\n\n    _this.removePointers = function () {\n      var _this$state = _this.state,\n          currentTarget = _this$state.currentTarget,\n          pointerId = _this$state.pointerId; // @ts-ignore\n\n      if (currentTarget) currentTarget.releasePointerCapture(pointerId);\n    };\n\n    _this.setListeners = function () {\n      _this.removeWindowListeners();\n\n      var dragListeners = [['touchmove', _this.onDragChange], ['touchend', _this.onDragEnd], ['touchcancel', _this.onDragEnd], ['mousemove', _this.onDragChange], ['mouseup', _this.onDragEnd]];\n\n      _this.addWindowListeners(dragListeners);\n    };\n\n    _this.onDragStart = function (event) {\n      if (!_this.dragShouldStart(event)) return; // if pointers events\n\n      if (_this.controller.config.pointer) _this.setPointers(event);else _this.setListeners();\n\n      if (_this.config.delay > 0) {\n        _this.state._delayedEvent = true;\n        if (typeof event.persist === 'function') event.persist();\n\n        _this.setTimeout(function () {\n          return _this.startDrag(event);\n        }, _this.config.delay);\n      } else {\n        _this.startDrag(event);\n      }\n    };\n\n    _this.onDragChange = function (event) {\n      var canceled = _this.state.canceled;\n      if (canceled) return;\n\n      if (!_this.state._active) {\n        if (_this.state._delayedEvent) {\n          _this.clearTimeout();\n\n          _this.startDrag(event);\n        }\n\n        return;\n      }\n\n      var genericEventData = getGenericEventData(event);\n\n      if (!genericEventData.down) {\n        _this.onDragEnd(event);\n\n        return;\n      }\n\n      _this.updateSharedState(genericEventData);\n\n      var _getPointerEventValue = getPointerEventValues(event),\n          values = _getPointerEventValue.values;\n\n      var kinematics = _this.getKinematics(values, event);\n\n      var _isTap = _this.state._isTap;\n      if (_isTap && calculateDistance(kinematics._movement) >= TAP_DISTANCE_THRESHOLD) _isTap = false;\n\n      _this.updateGestureState(_extends({}, _this.getGenericPayload(event), {}, kinematics, {\n        _isTap: _isTap,\n        cancel: function cancel() {\n          return _this.onCancel();\n        }\n      }));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onDragEnd = function (event) {\n      _this.state._active = false;\n\n      _this.updateSharedState({\n        down: false,\n        buttons: 0,\n        touches: 0\n      });\n\n      var _this$state2 = _this.state,\n          _isTap = _this$state2._isTap,\n          values = _this$state2.values,\n          _this$state2$velociti = _this$state2.velocities,\n          vx = _this$state2$velociti[0],\n          vy = _this$state2$velociti[1],\n          _this$state2$movement = _this$state2.movement,\n          mx = _this$state2$movement[0],\n          my = _this$state2$movement[1],\n          _this$state2$_intenti = _this$state2._intentional,\n          ix = _this$state2$_intenti[0],\n          iy = _this$state2$_intenti[1];\n\n      var endState = _extends({}, _this.getGenericPayload(event), {}, _this.getMovement(values));\n\n      var elapsedTime = endState.elapsedTime;\n      var _this$config = _this.config,\n          _this$config$swipeVel = _this$config.swipeVelocity,\n          svx = _this$config$swipeVel[0],\n          svy = _this$config$swipeVel[1],\n          _this$config$swipeDis = _this$config.swipeDistance,\n          sx = _this$config$swipeDis[0],\n          sy = _this$config$swipeDis[1];\n      var swipe = [0, 0];\n\n      if (elapsedTime < SWIPE_MAX_ELAPSED_TIME) {\n        if (ix !== false && Math.abs(vx) > svx && Math.abs(mx) > sx) swipe[0] = Math.sign(vx);\n        if (iy !== false && Math.abs(vy) > svy && Math.abs(my) > sy) swipe[1] = Math.sign(vy);\n      }\n\n      _this.updateGestureState(_extends({\n        event: event\n      }, endState, {\n        tap: _isTap,\n        swipe: swipe\n      }));\n\n      _this.fireGestureHandler(_this.config.filterTaps && _this.state._isTap);\n    };\n\n    _this.clean = function () {\n      _CoordinatesRecognize.prototype.clean.call(_assertThisInitialized(_this));\n\n      _this.state._delayedEvent = false;\n      if (_this.controller.config.pointer) _this.removePointers();\n    };\n\n    _this.onCancel = function () {\n      _this.updateGestureState({\n        canceled: true,\n        cancel: noop\n      });\n\n      _this.state._active = false;\n\n      _this.updateSharedState({\n        down: false,\n        buttons: 0,\n        touches: 0\n      });\n\n      requestAnimationFrame(function () {\n        return _this.fireGestureHandler();\n      });\n    };\n\n    return _this;\n  }\n\n  var _proto = DragRecognizer.prototype;\n\n  _proto.startDrag = function startDrag(event) {\n    var _this2 = this;\n\n    var _getPointerEventValue2 = getPointerEventValues(event),\n        values = _getPointerEventValue2.values;\n\n    this.updateSharedState(getGenericEventData(event));\n\n    var startState = _extends({}, this.getStartGestureState(values, event), {}, this.getGenericPayload(event, true));\n\n    this.updateGestureState(_extends({}, startState, {}, this.getMovement(values, startState), {\n      cancel: function cancel() {\n        return _this2.onCancel();\n      }\n    }));\n    this.fireGestureHandler();\n  };\n\n  _proto.addBindings = function addBindings() {\n    if (this.controller.config.pointer) {\n      this.controller.addBindings('onPointerDown', this.onDragStart);\n      this.controller.addBindings('onPointerMove', this.onDragChange);\n      this.controller.addBindings(['onPointerUp', 'onPointerCancel'], this.onDragEnd);\n    } else {\n      this.controller.addBindings(['onTouchStart', 'onMouseDown'], this.onDragStart);\n    }\n  };\n\n  return DragRecognizer;\n}(CoordinatesRecognizer);\n\nvar DEFAULT_DRAG_DELAY = 180;\nvar DEFAULT_RUBBERBAND = 0.15;\n\nfunction getWindow() {\n  return typeof window !== 'undefined' ? window : undefined;\n}\n/**\r\n * @private\r\n *\r\n * Returns the internal generic option object.\r\n *\r\n * @param {Partial<GenericOptions>} [config={}]\r\n * @returns {InternalGenericOptions}\r\n */\n\n\nfunction getInternalGenericOptions(config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  var defaultOptions = {\n    domTarget: undefined,\n    eventOptions: {\n      passive: true,\n      capture: false,\n      pointer: false\n    },\n    window: getWindow(),\n    enabled: true\n  };\n\n  var defaultEventOptions = defaultOptions.eventOptions,\n      defaultWindow = defaultOptions.window,\n      restDefault = _objectWithoutPropertiesLoose(defaultOptions, [\"eventOptions\", \"window\"]);\n\n  var _config = config,\n      eventOptions = _config.eventOptions,\n      window = _config.window,\n      restConfig = _objectWithoutPropertiesLoose(_config, [\"eventOptions\", \"window\"]);\n\n  var _defaultEventOptions$ = _extends({}, defaultEventOptions, {}, eventOptions),\n      passive = _defaultEventOptions$.passive,\n      capture = _defaultEventOptions$.capture,\n      pointer = _defaultEventOptions$.pointer;\n\n  return _extends({}, restDefault, {}, restConfig, {\n    window: window || defaultWindow,\n    // passive is always true if there's no domTarget\n    eventOptions: {\n      passive: !config.domTarget || !!passive,\n      capture: !!capture\n    },\n    captureString: capture ? 'Capture' : '',\n    pointer: !!pointer\n  });\n}\n\nfunction getInternalGestureOptions(gestureConfig) {\n  var defaultGestureOptions = {\n    enabled: true,\n    initial: [0, 0],\n    threshold: undefined,\n    rubberband: 0\n  };\n\n  var config = _extends({}, defaultGestureOptions, {}, gestureConfig);\n\n  var threshold = config.threshold,\n      rubberband = config.rubberband,\n      enabled = config.enabled,\n      initial = config.initial;\n  if (typeof rubberband === 'boolean') rubberband = rubberband ? DEFAULT_RUBBERBAND : 0;\n  if (threshold === void 0) threshold = 0;\n  return {\n    enabled: enabled,\n    initial: initial,\n    threshold: def.array(threshold),\n    rubberband: def.array(rubberband)\n  };\n}\n\nfunction getInternalCoordinatesOptions(coordinatesConfig) {\n  if (coordinatesConfig === void 0) {\n    coordinatesConfig = {};\n  }\n\n  var defaultCoordinatesOptions = {\n    lockDirection: false,\n    axis: undefined,\n    bounds: undefined\n  };\n\n  var _coordinatesConfig = coordinatesConfig,\n      axis = _coordinatesConfig.axis,\n      lockDirection = _coordinatesConfig.lockDirection,\n      _coordinatesConfig$bo = _coordinatesConfig.bounds,\n      bounds = _coordinatesConfig$bo === void 0 ? {} : _coordinatesConfig$bo,\n      internalOptions = _objectWithoutPropertiesLoose(_coordinatesConfig, [\"axis\", \"lockDirection\", \"bounds\"]);\n\n  var boundsArray = [[def.withDefault(bounds.left, -Infinity), def.withDefault(bounds.right, Infinity)], [def.withDefault(bounds.top, -Infinity), def.withDefault(bounds.bottom, Infinity)]];\n  return _extends({}, getInternalGestureOptions(internalOptions), {}, defaultCoordinatesOptions, {}, matchKeysFromObject({\n    axis: axis,\n    lockDirection: lockDirection\n  }, coordinatesConfig), {\n    bounds: boundsArray\n  });\n}\n\nfunction getInternalDistanceAngleOptions(distanceAngleConfig) {\n  if (distanceAngleConfig === void 0) {\n    distanceAngleConfig = {};\n  }\n\n  var _distanceAngleConfig = distanceAngleConfig,\n      _distanceAngleConfig$ = _distanceAngleConfig.distanceBounds,\n      distanceBounds = _distanceAngleConfig$ === void 0 ? {} : _distanceAngleConfig$,\n      _distanceAngleConfig$2 = _distanceAngleConfig.angleBounds,\n      angleBounds = _distanceAngleConfig$2 === void 0 ? {} : _distanceAngleConfig$2,\n      internalOptions = _objectWithoutPropertiesLoose(_distanceAngleConfig, [\"distanceBounds\", \"angleBounds\"]);\n\n  var boundsArray = [[def.withDefault(distanceBounds.min, -Infinity), def.withDefault(distanceBounds.max, Infinity)], [def.withDefault(angleBounds.min, -Infinity), def.withDefault(angleBounds.max, Infinity)]];\n  return _extends({}, getInternalGestureOptions(internalOptions), {\n    bounds: boundsArray\n  });\n}\n\nfunction getInternalDragOptions(dragConfig) {\n  if (dragConfig === void 0) {\n    dragConfig = {};\n  }\n\n  var defaultDragOptions = {\n    filterTaps: false,\n    swipeVelocity: 0.5,\n    swipeDistance: 60,\n    delay: false\n  };\n\n  var _dragConfig = dragConfig,\n      enabled = _dragConfig.enabled,\n      threshold = _dragConfig.threshold,\n      bounds = _dragConfig.bounds,\n      rubberband = _dragConfig.rubberband,\n      initial = _dragConfig.initial,\n      dragOptions = _objectWithoutPropertiesLoose(_dragConfig, [\"enabled\", \"threshold\", \"bounds\", \"rubberband\", \"initial\"]);\n\n  var _defaultDragOptions$d = _extends({}, defaultDragOptions, {}, dragOptions),\n      swipeVelocity = _defaultDragOptions$d.swipeVelocity,\n      swipeDistance = _defaultDragOptions$d.swipeDistance,\n      delay = _defaultDragOptions$d.delay,\n      filterTaps = _defaultDragOptions$d.filterTaps,\n      axis = _defaultDragOptions$d.axis,\n      lockDirection = _defaultDragOptions$d.lockDirection;\n\n  if (threshold === void 0) {\n    threshold = Math.max(0, filterTaps ? 3 : 0, lockDirection || axis ? 1 : 0);\n  } else {\n    filterTaps = true;\n  }\n\n  var internalCoordinatesOptions = getInternalCoordinatesOptions(matchKeysFromObject({\n    enabled: enabled,\n    threshold: threshold,\n    bounds: bounds,\n    rubberband: rubberband,\n    axis: axis,\n    lockDirection: lockDirection,\n    initial: initial\n  }, dragConfig));\n  return _extends({}, internalCoordinatesOptions, {\n    filterTaps: filterTaps || internalCoordinatesOptions.threshold[0] + internalCoordinatesOptions.threshold[1] > 0,\n    swipeVelocity: def.array(swipeVelocity),\n    swipeDistance: def.array(swipeDistance),\n    delay: typeof delay === 'number' ? delay : delay ? DEFAULT_DRAG_DELAY : 0\n  });\n}\n/**\r\n * @public\r\n *\r\n * Drag hook.\r\n *\r\n * @param {Handler<'drag'>} handler - the function fired every time the drag gesture updates\r\n * @param {(Config | {})} [config={}] - the config object including generic options and drag options\r\n * @returns {(...args: any[]) => HookReturnType<Config>}\r\n */\n\n\nfunction useDrag(handler, config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  var _config = config,\n      domTarget = _config.domTarget,\n      eventOptions = _config.eventOptions,\n      window = _config.window,\n      drag = _objectWithoutPropertiesLoose(_config, [\"domTarget\", \"eventOptions\", \"window\"]);\n  /**\r\n   * TODO: at the moment we recompute the config object at every render\r\n   * this could probably be optimized\r\n   */\n\n\n  var mergedConfig = _extends({}, getInternalGenericOptions({\n    domTarget: domTarget,\n    eventOptions: eventOptions,\n    window: window\n  }), {\n    drag: getInternalDragOptions(drag)\n  });\n\n  return useRecognizers({\n    drag: handler\n  }, [DragRecognizer], mergedConfig);\n}\n/**\r\n * @private\r\n * Abstract class for distance/angle-based gesture recongizers\r\n * @abstract\r\n * @class DistanceAngleRecognizer\r\n * @extends {Recognizer<T>}\r\n * @template T\r\n */\n\n\nvar DistanceAngleRecognizer =\n/*#__PURE__*/\nfunction (_Recognizer) {\n  _inheritsLoose(DistanceAngleRecognizer, _Recognizer);\n\n  function DistanceAngleRecognizer() {\n    return _Recognizer.apply(this, arguments) || this;\n  }\n\n  var _proto = DistanceAngleRecognizer.prototype;\n  /**\r\n   * Returns the real movement (without taking intentionality into acount)\r\n   */\n\n  _proto.getInternalMovement = function getInternalMovement(_ref, state) {\n    var d = _ref[0],\n        a = _ref[1];\n    var da = state.values,\n        turns = state.turns,\n        initial = state.initial; // angle might not be defined when ctrl wheel is used for zoom only\n    // in that case we set it to the previous angle value\n\n    a = a !== void 0 ? a : da[1];\n    var delta_a = a - da[1];\n    /**\r\n     * The angle value might jump from 179deg to -179deg when we actually want to\r\n     * read 181deg to ensure continuity. To make that happen, we detect when the jump\r\n     * is supsiciously high (ie > 270deg) and increase the `turns` value\r\n     */\n\n    var newTurns = Math.abs(delta_a) > 270 ? turns + Math.sign(delta_a) : turns; // we update the angle difference to its corrected value\n\n    var movement_d = d - initial[0];\n    var movement_a = a - 360 * newTurns - initial[1];\n    return [movement_d, movement_a];\n  };\n\n  _proto.getKinematics = function getKinematics(values, event) {\n    var _this$state = this.state,\n        timeStamp = _this$state.timeStamp,\n        initial = _this$state.initial;\n    var movementDetection = this.getMovement(values, this.state);\n    var delta = movementDetection.delta,\n        movement = movementDetection.movement;\n    var turns = (values[1] - movement[1] - initial[1]) / 360;\n    var delta_t = event.timeStamp - timeStamp;\n    var kinematics = calculateAllKinematics(movement, delta, delta_t);\n    return _extends({\n      values: values,\n      delta: delta,\n      turns: turns\n    }, movementDetection, {}, kinematics);\n  };\n\n  _proto.mapStateValues = function mapStateValues(state) {\n    return {\n      da: state.values,\n      vdva: state.velocities\n    };\n  };\n\n  return DistanceAngleRecognizer;\n}(Recognizer);\n\nvar PinchRecognizer =\n/*#__PURE__*/\nfunction (_DistanceAngleRecogni) {\n  _inheritsLoose(PinchRecognizer, _DistanceAngleRecogni);\n\n  function PinchRecognizer(controller, args) {\n    var _this;\n\n    _this = _DistanceAngleRecogni.call(this, 'pinch', controller, args) || this;\n    _this.ingKey = 'pinching';\n\n    _this.pinchShouldStart = function (event) {\n      var _getGenericEventData = getGenericEventData(event),\n          touches = _getGenericEventData.touches;\n\n      return _this.enabled && touches === 2;\n    };\n\n    _this.onPinchStart = function (event) {\n      if (!_this.pinchShouldStart(event)) return;\n\n      var _getTwoTouchesEventDa = getTwoTouchesEventData(event),\n          values = _getTwoTouchesEventDa.values,\n          origin = _getTwoTouchesEventDa.origin;\n\n      _this.updateSharedState(getGenericEventData(event));\n\n      var startState = _extends({}, _this.getStartGestureState(values, event), {}, _this.getGenericPayload(event, true));\n\n      _this.updateGestureState(_extends({}, startState, {}, _this.getMovement(values, startState), {\n        origin: origin,\n        cancel: function cancel() {\n          return _this.onCancel();\n        }\n      }));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onPinchChange = function (event) {\n      var _this$state = _this.state,\n          canceled = _this$state.canceled,\n          timeStamp = _this$state.timeStamp,\n          _active = _this$state._active;\n      if (canceled || !_active) return;\n      var genericEventData = getGenericEventData(event);\n      if (genericEventData.touches !== 2 || event.timeStamp === timeStamp) return;\n\n      _this.updateSharedState(genericEventData);\n\n      var _getTwoTouchesEventDa2 = getTwoTouchesEventData(event),\n          values = _getTwoTouchesEventDa2.values,\n          origin = _getTwoTouchesEventDa2.origin;\n\n      var kinematics = _this.getKinematics(values, event);\n\n      _this.updateGestureState(_extends({}, _this.getGenericPayload(event), {}, kinematics, {\n        origin: origin,\n        cancel: function cancel() {\n          return _this.onCancel();\n        }\n      }));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onPinchEnd = function (event) {\n      _this.state._active = false;\n\n      _this.updateSharedState({\n        down: false,\n        touches: 0\n      });\n\n      _this.updateGestureState(_extends({\n        event: event\n      }, _this.getGenericPayload(event), {}, _this.getMovement(_this.state.values)));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onCancel = function () {\n      _this.state._active = false;\n\n      _this.updateGestureState({\n        canceled: true,\n        cancel: noop\n      });\n\n      _this.updateSharedState({\n        down: false,\n        touches: 0\n      });\n\n      requestAnimationFrame(function () {\n        return _this.fireGestureHandler();\n      });\n    };\n    /**\r\n     * PINCH WITH WEBKIT GESTURES\r\n     */\n\n\n    _this.onGestureStart = function (event) {\n      if (!_this.enabled) return;\n      event.preventDefault();\n\n      var _getWebkitGestureEven = getWebkitGestureEventValues(event),\n          values = _getWebkitGestureEven.values;\n\n      _this.updateSharedState(getGenericEventData(event));\n\n      var startState = _extends({}, _this.getStartGestureState(values, event), {}, _this.getGenericPayload(event, true));\n\n      _this.updateGestureState(_extends({}, startState, {}, _this.getMovement(values, startState), {\n        cancel: function cancel() {\n          return _this.onCancel();\n        }\n      }));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onGestureChange = function (event) {\n      var _this$state2 = _this.state,\n          canceled = _this$state2.canceled,\n          _active = _this$state2._active;\n      if (canceled || !_active) return;\n      event.preventDefault();\n      var genericEventData = getGenericEventData(event);\n\n      _this.updateSharedState(genericEventData);\n\n      var _getWebkitGestureEven2 = getWebkitGestureEventValues(event),\n          values = _getWebkitGestureEven2.values;\n\n      var kinematics = _this.getKinematics(values, event);\n\n      _this.updateGestureState(_extends({}, _this.getGenericPayload(event), {}, kinematics, {\n        cancel: function cancel() {\n          return _this.onCancel();\n        }\n      }));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onGestureEnd = function (event) {\n      event.preventDefault();\n      _this.state._active = false;\n\n      _this.updateSharedState({\n        down: false,\n        touches: 0\n      });\n\n      _this.updateGestureState(_extends({\n        event: event\n      }, _this.getGenericPayload(event), {}, _this.getMovement(_this.state.values)));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.updateTouchData = function (event) {\n      if (!_this.enabled || event.touches.length !== 2) return;\n\n      var _getTwoTouchesEventDa3 = getTwoTouchesEventData(event),\n          origin = _getTwoTouchesEventDa3.origin;\n\n      _this.state.origin = origin;\n    };\n    /**\r\n     * PINCH WITH WHEEL\r\n     */\n\n\n    _this.wheelShouldRun = function (event) {\n      return _this.enabled && event.ctrlKey;\n    };\n\n    _this.getWheelValuesFromEvent = function (event) {\n      var _getWheelEventValues = getWheelEventValues(event),\n          _getWheelEventValues$ = _getWheelEventValues.values,\n          delta_d = _getWheelEventValues$[1];\n\n      var _this$state$values = _this.state.values,\n          prev_d = _this$state$values[0],\n          prev_a = _this$state$values[1];\n      var d = prev_d - delta_d;\n      var a = prev_a !== void 0 ? prev_a : 0;\n      return {\n        values: [d, a],\n        origin: [event.clientX, event.clientY],\n        delta: [0, delta_d]\n      };\n    };\n\n    _this.onWheel = function (event) {\n      if (!_this.wheelShouldRun(event)) return;\n\n      _this.clearTimeout();\n\n      _this.setTimeout(_this.onWheelEnd);\n\n      if (!_this.state._active) _this.onWheelStart(event);else _this.onWheelChange(event);\n    };\n\n    _this.onWheelStart = function (event) {\n      var _this$getWheelValuesF = _this.getWheelValuesFromEvent(event),\n          values = _this$getWheelValuesF.values,\n          delta = _this$getWheelValuesF.delta,\n          origin = _this$getWheelValuesF.origin;\n\n      if (!_this.controller.config.eventOptions.passive) {\n        event.preventDefault();\n      } else if (process.env.NODE_ENV === 'development') {\n        console.warn('To support zoom on trackpads, try using the `domTarget` option and `config.event.passive` set to `false`. This message will only appear in development mode.');\n      }\n\n      _this.updateSharedState(getGenericEventData(event));\n\n      var startState = _extends({}, _this.getStartGestureState(values, event), {}, _this.getGenericPayload(event, true), {\n        initial: _this.state.values\n      });\n\n      _this.updateGestureState(_extends({}, startState, {}, _this.getMovement(values, startState), {\n        offset: values,\n        delta: delta,\n        origin: origin\n      }));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onWheelChange = function (event) {\n      var genericEventData = getGenericEventData(event);\n\n      _this.updateSharedState(genericEventData);\n\n      var _this$getWheelValuesF2 = _this.getWheelValuesFromEvent(event),\n          values = _this$getWheelValuesF2.values,\n          origin = _this$getWheelValuesF2.origin,\n          delta = _this$getWheelValuesF2.delta;\n\n      var kinematics = _this.getKinematics(values, event);\n\n      _this.updateGestureState(_extends({}, _this.getGenericPayload(event), {}, kinematics, {\n        origin: origin,\n        delta: delta\n      }));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onWheelEnd = function () {\n      _this.state._active = false;\n\n      _this.updateGestureState(_this.getMovement(_this.state.values));\n\n      _this.fireGestureHandler();\n    };\n\n    return _this;\n  }\n\n  var _proto = PinchRecognizer.prototype;\n\n  _proto.addBindings = function addBindings() {\n    if (supportsGestureEvents()) {\n      this.controller.addBindings('onGestureStart', this.onGestureStart);\n      this.controller.addBindings('onGestureChange', this.onGestureChange);\n      this.controller.addBindings(['onGestureEnd', 'onTouchCancel'], this.onGestureEnd);\n      this.controller.addBindings(['onTouchStart', 'onTouchMove'], this.updateTouchData);\n    } else {\n      this.controller.addBindings('onTouchStart', this.onPinchStart);\n      this.controller.addBindings('onTouchMove', this.onPinchChange);\n      this.controller.addBindings(['onTouchEnd', 'onTouchCancel'], this.onPinchEnd);\n      this.controller.addBindings('onWheel', this.onWheel);\n    }\n  };\n\n  return PinchRecognizer;\n}(DistanceAngleRecognizer);\n/**\r\n * @public\r\n *\r\n * Pinch hook.\r\n *\r\n * @param {Handler<'pinch'>} handler - the function fired every time the pinch gesture updates\r\n * @param {(Config | {})} [config={}] - the config object including generic options and pinch options\r\n * @returns {(...args: any[]) => HookReturnType<Config>}\r\n */\n\n\nfunction usePinch(handler, config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  var _config = config,\n      domTarget = _config.domTarget,\n      eventOptions = _config.eventOptions,\n      window = _config.window,\n      pinch = _objectWithoutPropertiesLoose(_config, [\"domTarget\", \"eventOptions\", \"window\"]);\n  /**\r\n   * TODO: at the moment we recompute the config object at every render\r\n   * this could probably be optimized\r\n   */\n\n\n  var mergedConfig = _extends({}, getInternalGenericOptions({\n    domTarget: domTarget,\n    eventOptions: eventOptions,\n    window: window\n  }), {\n    pinch: getInternalDistanceAngleOptions(pinch)\n  });\n\n  return useRecognizers({\n    pinch: handler\n  }, [PinchRecognizer], mergedConfig);\n}\n\nvar WheelRecognizer =\n/*#__PURE__*/\nfunction (_CoordinatesRecognize) {\n  _inheritsLoose(WheelRecognizer, _CoordinatesRecognize);\n\n  function WheelRecognizer(controller, args) {\n    var _this;\n\n    _this = _CoordinatesRecognize.call(this, 'wheel', controller, args) || this;\n    _this.ingKey = 'wheeling';\n\n    _this.wheelShouldRun = function (event) {\n      if (event.ctrlKey && 'pinch' in _this.controller.handlers) return false;\n      return _this.enabled;\n    };\n\n    _this.getValuesFromEvent = function (event) {\n      var prevValues = _this.state.values;\n\n      var _getWheelEventValues = getWheelEventValues(event),\n          values = _getWheelEventValues.values;\n\n      return {\n        values: addV(values, prevValues)\n      };\n    };\n\n    _this.onWheel = function (event) {\n      if (!_this.wheelShouldRun(event)) return;\n\n      _this.clearTimeout();\n\n      _this.setTimeout(_this.onWheelEnd);\n\n      if (!_this.state._active) _this.onWheelStart(event);else _this.onWheelChange(event);\n    };\n\n    _this.onWheelStart = function (event) {\n      var _this$getValuesFromEv = _this.getValuesFromEvent(event),\n          values = _this$getValuesFromEv.values;\n\n      _this.updateSharedState(getGenericEventData(event));\n\n      var startState = _extends({}, _this.getStartGestureState(values, event), {}, _this.getGenericPayload(event, true), {\n        initial: _this.state.values\n      });\n\n      var movementDetection = _this.getMovement(values, startState);\n\n      var delta = movementDetection.delta;\n\n      _this.updateGestureState(_extends({}, startState, {}, movementDetection, {\n        distance: calculateDistance(delta),\n        direction: calculateDirection(delta)\n      }));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onWheelChange = function (event) {\n      var genericEventData = getGenericEventData(event);\n\n      _this.updateSharedState(genericEventData);\n\n      var _this$getValuesFromEv2 = _this.getValuesFromEvent(event),\n          values = _this$getValuesFromEv2.values;\n\n      var kinematics = _this.getKinematics(values, event);\n\n      _this.updateGestureState(_extends({}, _this.getGenericPayload(event), {}, kinematics));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onWheelEnd = function () {\n      _this.state._active = false;\n\n      _this.updateGestureState(_extends({}, _this.getMovement(_this.state.values), {\n        velocities: [0, 0],\n        velocity: 0\n      }));\n\n      _this.fireGestureHandler();\n    };\n\n    return _this;\n  }\n\n  var _proto = WheelRecognizer.prototype;\n\n  _proto.addBindings = function addBindings() {\n    this.controller.addBindings('onWheel', this.onWheel);\n  };\n\n  return WheelRecognizer;\n}(CoordinatesRecognizer);\n/**\r\n * @public\r\n *\r\n * Wheel hook.\r\n *\r\n * @param {Handler<'wheel'>} handler - the function fired every time the wheel gesture updates\r\n * @param {(Config | {})} [config={}] - the config object including generic options and wheel options\r\n * @returns {(...args: any[]) => HookReturnType<Config>}\r\n */\n\n\nfunction useWheel(handler, config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  var _config = config,\n      domTarget = _config.domTarget,\n      eventOptions = _config.eventOptions,\n      window = _config.window,\n      wheel = _objectWithoutPropertiesLoose(_config, [\"domTarget\", \"eventOptions\", \"window\"]);\n  /**\r\n   * TODO: at the moment we recompute the config object at every render\r\n   * this could probably be optimized\r\n   */\n\n\n  var mergedConfig = _extends({}, getInternalGenericOptions({\n    domTarget: domTarget,\n    eventOptions: eventOptions,\n    window: window\n  }), {\n    wheel: getInternalCoordinatesOptions(wheel)\n  });\n\n  return useRecognizers({\n    wheel: handler\n  }, [WheelRecognizer], mergedConfig);\n}\n\nvar MoveRecognizer =\n/*#__PURE__*/\nfunction (_CoordinatesRecognize) {\n  _inheritsLoose(MoveRecognizer, _CoordinatesRecognize);\n\n  function MoveRecognizer(controller, args) {\n    var _this;\n\n    _this = _CoordinatesRecognize.call(this, 'move', controller, args) || this;\n    _this.ingKey = 'moving';\n\n    _this.moveShouldRun = function () {\n      return _this.enabled;\n    };\n\n    _this.onMove = function (event) {\n      if (!_this.moveShouldRun()) return;\n\n      _this.clearTimeout();\n\n      _this.setTimeout(_this.onMoveEnd);\n\n      if (!_this.state._active) _this.onMoveStart(event);else _this.onMoveChange(event);\n    };\n\n    _this.onMoveStart = function (event) {\n      var _getPointerEventValue = getPointerEventValues(event),\n          values = _getPointerEventValue.values;\n\n      _this.updateSharedState(getGenericEventData(event));\n\n      var startState = _extends({}, _this.getStartGestureState(values, event), {}, _this.getGenericPayload(event, true));\n\n      _this.updateGestureState(_extends({}, startState, {}, _this.getMovement(values, startState)));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onMoveChange = function (event) {\n      var genericEventData = getGenericEventData(event);\n\n      _this.updateSharedState(genericEventData);\n\n      var _getPointerEventValue2 = getPointerEventValues(event),\n          values = _getPointerEventValue2.values;\n\n      var kinematics = _this.getKinematics(values, event);\n\n      _this.updateGestureState(_extends({}, _this.getGenericPayload(event), {}, kinematics));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onMoveEnd = function () {\n      _this.state._active = false;\n\n      _this.updateGestureState(_extends({}, _this.getMovement(_this.state.values), {\n        velocities: [0, 0],\n        velocity: 0\n      }));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onPointerEnter = function (event) {\n      _this.controller.state.shared.hovering = true;\n      if (!_this.controller.config.enabled) return;\n\n      if (_this.controller.config.hover.enabled) {\n        var _getPointerEventValue3 = getPointerEventValues(event),\n            values = _getPointerEventValue3.values;\n\n        var state = _extends({}, _this.controller.state.shared, {}, _this.state, {}, _this.getGenericPayload(event, true), {\n          values: values,\n          active: true,\n          hovering: true\n        });\n\n        _this.controller.handlers.hover(_extends({}, state, {}, _this.mapStateValues(state)));\n      }\n\n      if ('move' in _this.controller.handlers) _this.onMoveStart(event);\n    };\n\n    _this.onPointerLeave = function (event) {\n      _this.controller.state.shared.hovering = false;\n\n      if (_this.controller.config.hover.enabled) {\n        var _getPointerEventValue4 = getPointerEventValues(event),\n            values = _getPointerEventValue4.values;\n\n        var state = _extends({}, _this.controller.state.shared, {}, _this.state, {}, _this.getGenericPayload(event), {\n          values: values,\n          active: false\n        });\n\n        _this.controller.handlers.hover(_extends({}, state, {}, _this.mapStateValues(state)));\n      }\n\n      if ('move' in _this.controller.handlers) _this.onMoveEnd();\n    };\n\n    return _this;\n  }\n\n  var _proto = MoveRecognizer.prototype;\n\n  _proto.addBindings = function addBindings() {\n    if (this.controller.config.pointer) {\n      if ('move' in this.controller.handlers) {\n        this.controller.addBindings('onPointerMove', this.onMove);\n      }\n\n      if ('hover' in this.controller.handlers) {\n        this.controller.addBindings('onPointerEnter', this.onPointerEnter);\n        this.controller.addBindings('onPointerLeave', this.onPointerLeave);\n      }\n    } else {\n      if ('move' in this.controller.handlers) {\n        this.controller.addBindings('onMouseMove', this.onMove);\n      }\n\n      if ('hover' in this.controller.handlers) {\n        this.controller.addBindings('onMouseEnter', this.onPointerEnter);\n        this.controller.addBindings('onMouseLeave', this.onPointerLeave);\n      }\n    }\n  };\n\n  return MoveRecognizer;\n}(CoordinatesRecognizer);\n/**\r\n * @public\r\n *\r\n * Move hook.\r\n *\r\n * @param {Handler<'move'>} handler - the function fired every time the move gesture updates\r\n * @param {(Config | {})} [config={}] - the config object including generic options and move options\r\n * @returns {(...args: any[]) => HookReturnType<Config>}\r\n */\n\n\nfunction useMove(handler, config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  var _config = config,\n      domTarget = _config.domTarget,\n      eventOptions = _config.eventOptions,\n      window = _config.window,\n      move = _objectWithoutPropertiesLoose(_config, [\"domTarget\", \"eventOptions\", \"window\"]);\n  /**\r\n   * TODO: at the moment we recompute the config object at every render\r\n   * this could probably be optimized\r\n   */\n\n\n  var mergedConfig = _extends({}, getInternalGenericOptions({\n    domTarget: domTarget,\n    eventOptions: eventOptions,\n    window: window\n  }), {\n    move: getInternalCoordinatesOptions(move)\n  });\n\n  return useRecognizers({\n    move: handler\n  }, [MoveRecognizer], mergedConfig);\n}\n/**\r\n * @public\r\n *\r\n * Hover hook.\r\n *\r\n * @param {Handler<'hover'>} handler - the function fired every time the hover gesture updates\r\n * @param {(Config | {})} [config={}] - the config object including generic options and hover options\r\n * @returns {(...args: any[]) => HookReturnType<Config>}\r\n */\n\n\nfunction useHover(handler, config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  var _config = config,\n      domTarget = _config.domTarget,\n      eventOptions = _config.eventOptions,\n      window = _config.window,\n      hover = _objectWithoutPropertiesLoose(_config, [\"domTarget\", \"eventOptions\", \"window\"]);\n  /**\r\n   * TODO: at the moment we recompute the config object at every render\r\n   * this could probably be optimized\r\n   */\n\n\n  var mergedConfig = _extends({}, getInternalGenericOptions({\n    domTarget: domTarget,\n    eventOptions: eventOptions,\n    window: window\n  }), {\n    hover: _extends({\n      enabled: true\n    }, hover)\n  });\n\n  return useRecognizers({\n    hover: handler\n  }, [MoveRecognizer], mergedConfig);\n}\n\nvar ScrollRecognizer =\n/*#__PURE__*/\nfunction (_CoordinatesRecognize) {\n  _inheritsLoose(ScrollRecognizer, _CoordinatesRecognize);\n\n  function ScrollRecognizer(controller, args) {\n    var _this;\n\n    _this = _CoordinatesRecognize.call(this, 'scroll', controller, args) || this;\n    _this.ingKey = 'scrolling';\n\n    _this.scrollShouldRun = function () {\n      return _this.enabled;\n    };\n\n    _this.onScroll = function (event) {\n      if (!_this.scrollShouldRun()) return;\n\n      _this.clearTimeout();\n\n      _this.setTimeout(_this.onScrollEnd);\n\n      if (!_this.state._active) _this.onScrollStart(event);else _this.onScrollChange(event);\n    };\n\n    _this.onScrollStart = function (event) {\n      var _getScrollEventValues = getScrollEventValues(event),\n          values = _getScrollEventValues.values;\n\n      _this.updateSharedState(getGenericEventData(event));\n\n      var startState = _extends({}, _this.getStartGestureState(values, event), {}, _this.getGenericPayload(event, true), {\n        initial: _this.state.values\n      });\n\n      var movementDetection = _this.getMovement(values, startState);\n\n      var delta = movementDetection.delta;\n\n      _this.updateGestureState(_extends({}, startState, {}, movementDetection, {\n        distance: calculateDistance(delta),\n        direction: calculateDirection(delta)\n      }));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onScrollChange = function (event) {\n      var genericEventData = getGenericEventData(event);\n\n      _this.updateSharedState(genericEventData);\n\n      var _getScrollEventValues2 = getScrollEventValues(event),\n          values = _getScrollEventValues2.values;\n\n      var kinematics = _this.getKinematics(values, event);\n\n      _this.updateGestureState(_extends({}, _this.getGenericPayload(event), {}, kinematics));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onScrollEnd = function () {\n      _this.state._active = false;\n\n      _this.updateGestureState(_extends({}, _this.getMovement(_this.state.values), {\n        velocities: [0, 0],\n        velocity: 0\n      }));\n\n      _this.fireGestureHandler();\n    };\n\n    return _this;\n  }\n\n  var _proto = ScrollRecognizer.prototype;\n\n  _proto.addBindings = function addBindings() {\n    this.controller.addBindings('onScroll', this.onScroll);\n  };\n\n  return ScrollRecognizer;\n}(CoordinatesRecognizer);\n/**\r\n * @public\r\n *\r\n * Scroll hook.\r\n *\r\n * @param {Handler<'scroll'>} handler - the function fired every time the scroll gesture updates\r\n * @param {(Config | {})} [config={}] - the config object including generic options and scroll options\r\n * @returns {(...args: any[]) => HookReturnType<Config>}\r\n */\n\n\nfunction useScroll(handler, config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  var _config = config,\n      domTarget = _config.domTarget,\n      eventOptions = _config.eventOptions,\n      window = _config.window,\n      scroll = _objectWithoutPropertiesLoose(_config, [\"domTarget\", \"eventOptions\", \"window\"]);\n  /**\r\n   * TODO: at the moment we recompute the config object at every render\r\n   * this could probably be optimized\r\n   */\n\n\n  var mergedConfig = _extends({}, getInternalGenericOptions({\n    domTarget: domTarget,\n    eventOptions: eventOptions,\n    window: window\n  }), {\n    scroll: getInternalCoordinatesOptions(scroll)\n  });\n\n  return useRecognizers({\n    scroll: handler\n  }, [ScrollRecognizer], mergedConfig);\n}\n/**\r\n * @public\r\n *\r\n * The most complete gesture hook, allowing support for multiple gestures.\r\n *\r\n * @param {UserHandlersPartial} handlers - an object with on[Gesture] keys containg gesture handlers\r\n * @param {UseGestureConfig} [config={}] - the full config object\r\n * @returns {(...args: any[]) => HookReturnType<Config>}\r\n */\n\n\nfunction useGesture(handlers, config) {\n  if (config === void 0) {\n    config = {};\n  }\n  /**\r\n   * If handlers contains {onDragStart, onDrag, onDragEnd, onMoveStart, onMove}\r\n   * actions will include 'onDrag' and 'onMove.\r\n   */\n\n\n  var _React$useState = React.useState(function () {\n    return new Set(Object.keys(handlers).map(function (k) {\n      return k.replace(/End|Start/, '');\n    }));\n  }),\n      actions = _React$useState[0];\n  /**\r\n   * Here we compute the derived internal config based on the provided config object.\r\n   * We decompose the config into its generic and gesture options and compute each.\r\n   * TODO: this is currently done on every render!\r\n   */\n\n\n  var _config = config,\n      drag = _config.drag,\n      wheel = _config.wheel,\n      move = _config.move,\n      scroll = _config.scroll,\n      pinch = _config.pinch,\n      hover = _config.hover,\n      restConfig = _objectWithoutPropertiesLoose(_config, [\"drag\", \"wheel\", \"move\", \"scroll\", \"pinch\", \"hover\"]);\n\n  var mergedConfig = getInternalGenericOptions(restConfig);\n  var classes = [];\n  var internalHandlers = {}; // will hold reference to native handlers such as onClick, onMouseDown, etc.\n\n  var _nativeHandlers = _extends({}, handlers);\n\n  if (actions.has('onDrag')) {\n    classes.push(DragRecognizer);\n    internalHandlers.drag = includeStartEndHandlers(handlers, 'onDrag', _nativeHandlers);\n    mergedConfig.drag = getInternalDragOptions(drag);\n  }\n\n  if (actions.has('onWheel')) {\n    classes.push(WheelRecognizer);\n    internalHandlers.wheel = includeStartEndHandlers(handlers, 'onWheel', _nativeHandlers);\n    mergedConfig.wheel = getInternalCoordinatesOptions(wheel);\n  }\n\n  if (actions.has('onScroll')) {\n    classes.push(ScrollRecognizer);\n    internalHandlers.scroll = includeStartEndHandlers(handlers, 'onScroll', _nativeHandlers);\n    mergedConfig.scroll = getInternalCoordinatesOptions(scroll);\n  }\n\n  if (actions.has('onMove')) {\n    classes.push(MoveRecognizer);\n    internalHandlers.move = includeStartEndHandlers(handlers, 'onMove', _nativeHandlers);\n    mergedConfig.move = getInternalCoordinatesOptions(move);\n  }\n\n  if (actions.has('onPinch')) {\n    classes.push(PinchRecognizer);\n    internalHandlers.pinch = includeStartEndHandlers(handlers, 'onPinch', _nativeHandlers);\n    mergedConfig.pinch = getInternalDistanceAngleOptions(pinch);\n  }\n\n  if (actions.has('onHover')) {\n    if (!actions.has('onMove')) classes.push(MoveRecognizer);\n    internalHandlers.hover = handlers.onHover;\n    mergedConfig.hover = _extends({\n      enabled: true\n    }, hover);\n    delete _nativeHandlers.onHover;\n  }\n\n  return useRecognizers(internalHandlers, classes, mergedConfig, _nativeHandlers);\n}\n/**\r\n * @private\r\n *\r\n * This utility function will integrate start and end handlers into the regular\r\n * handler function by using first and last conditions.\r\n *\r\n * @param {UserHandlersPartial} handlers - the handlers function object\r\n * @param {HandlerKey} handlerKey - the key for which to integrate start and end handlers\r\n * @returns\r\n */\n\n\nfunction includeStartEndHandlers(handlers, handlerKey, _nativeHandlers) {\n  var startKey = handlerKey + 'Start';\n  var endKey = handlerKey + 'End';\n  delete _nativeHandlers[handlerKey];\n  delete _nativeHandlers[startKey];\n  delete _nativeHandlers[endKey];\n\n  var fn = function fn(state) {\n    var memo = undefined;\n    if (state.first && startKey in handlers) handlers[startKey](state);\n    if (handlerKey in handlers) memo = handlers[handlerKey](state);\n    if (state.last && endKey in handlers) handlers[endKey](state);\n    return memo;\n  };\n\n  return fn;\n}\n\nexport { addV, rubberbandIfOutOfBounds, subV, useDrag, useGesture, useHover, useMove, usePinch, useScroll, useWheel };","map":{"version":3,"sources":["../src/utils/math.ts","../src/utils/utils.ts","../src/utils/state.ts","../src/utils/event.ts","../src/Controller.ts","../src/hooks/useRecognizers.ts","../src/recognizers/Recognizer.ts","../src/recognizers/CoordinatesRecognizer.ts","../src/recognizers/DragRecognizer.ts","../src/utils/config.ts","../src/hooks/useDrag.ts","../src/recognizers/DistanceAngleRecognizer.ts","../src/recognizers/PinchRecognizer.ts","../src/hooks/usePinch.ts","../src/recognizers/WheelRecognizer.ts","../src/hooks/useWheel.ts","../src/recognizers/MoveRecognizer.ts","../src/hooks/useMove.ts","../src/hooks/useHover.ts","../src/recognizers/ScrollRecognizer.ts","../src/hooks/useScroll.ts","../src/hooks/useGesture.ts"],"names":["addV","v1","v2","v","subV","calculateVelocity","delta","delta_t","len","Math","calculateVelocities","Array","calculateDistance","movement","calculateDirection","calculateAllKinematics","velocities","velocity","distance","direction","getIntentional","threshold","abs","constant","dimension","rubberband2","rubberbandIfOutOfBounds","position","min","max","minMax","rubberband","noop","chainFns","fns","args","fn","def","array","withDefault","value","matchKeysFromObject","obj","matchingObject","o","Object","key","valueFn","getInitialState","initialCommon","_active","_blocked","_intentional","_movement","_initial","event","values","offset","lastOffset","initial","previous","first","last","active","timeStamp","startTime","elapsedTime","cancel","canceled","memo","undefined","initialCoordinates","axis","xy","vxvy","initialDistanceAngle","da","vdva","origin","turns","shared","hovering","scrolling","wheeling","dragging","moving","pinching","touches","buttons","down","shiftKey","altKey","metaKey","ctrlKey","drag","_isTap","_delayedEvent","tap","swipe","pinch","wheel","move","scroll","setListeners","action","add","listeners","eventName","el","supportsGestureEvents","addListeners","removeListeners","getModifierKeys","changedTouches","getGenericEventData","touchEvents","getTouchEvents","getScrollEventValues","scrollX","scrollY","scrollLeft","scrollTop","currentTarget","getWheelEventValues","deltaX","deltaY","getPointerEventValues","clientX","clientY","WEBKIT_DISTANCE_SCALE_FACTOR","getWebkitGestureEventValues","getTwoTouchesEventData","dx","dy","Controller","domTarget","config","eventNamesArray","bindings","captureString","fnsArray","useRecognizers","handlers","classes","nativeHandlers","controller","React","nativeRefs","bind","recognizer","Recognizer","updateSharedState","updateGestureState","ms","clearTimeout","getGenericPayload","state","isStartEvent","checkIntentionality","getMovement","t0","t1","intentional","prevMovement","i0","i1","_m0","_m1","intentionalityCheck","_i0","_i1","_rubberband","bounds","clean","intentionalX","intentionalY","newMemo","CoordinatesRecognizer","getInternalMovement","_ix","_iy","intentionalMovement","absX","absY","configAxis","lockDirection","lockedIndex","getKinematics","movementDetection","kinematics","mapStateValues","TAP_DISTANCE_THRESHOLD","SWIPE_MAX_ELAPSED_TIME","DragRecognizer","pointerId","dragListeners","startDrag","startState","genericEventData","vx","vy","mx","my","ix","iy","endState","swipeVelocity","svx","svy","swipeDistance","sx","sy","requestAnimationFrame","addBindings","DEFAULT_DRAG_DELAY","DEFAULT_RUBBERBAND","getInternalGenericOptions","defaultOptions","eventOptions","passive","capture","pointer","window","getWindow","enabled","defaultEventOptions","defaultWindow","restDefault","restConfig","getInternalGestureOptions","gestureConfig","defaultGestureOptions","getInternalCoordinatesOptions","coordinatesConfig","defaultCoordinatesOptions","internalOptions","boundsArray","getInternalDistanceAngleOptions","distanceAngleConfig","distanceBounds","angleBounds","getInternalDragOptions","dragConfig","defaultDragOptions","filterTaps","delay","dragOptions","internalCoordinatesOptions","useDrag","handler","mergedConfig","DistanceAngleRecognizer","d","a","delta_a","newTurns","movement_d","movement_a","PinchRecognizer","delta_d","prev_d","prev_a","process","console","usePinch","WheelRecognizer","prevValues","useWheel","MoveRecognizer","useMove","useHover","hover","ScrollRecognizer","useScroll","useGesture","actions","k","internalHandlers","_nativeHandlers","includeStartEndHandlers","startKey","handlerKey","endKey"],"mappings":"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","sourcesContent":["// vector add\nexport function addV<T extends number[]>(v1: T, v2: T): T {\n  return v1.map((v, i) => v + v2[i]) as T\n}\n\n// vector substract\nexport function subV<T extends number[]>(v1: T, v2: T): T {\n  return v1.map((v, i) => v - v2[i]) as T\n}\n/**\n * Calculates velocity\n * @param delta the difference between current and previous vectors\n * @param delta_t the time offset\n * @param len the length of the delta vector\n * @returns velocity\n */\nexport function calculateVelocity(delta: number[], delta_t: number, len: number): number {\n  len = len || Math.hypot(...delta)\n  return delta_t ? len / delta_t : 0\n}\n\n/**\n * Calculates velocities vector\n * @template T the expected vector type\n * @param delta the difference between current and previous vectors\n * @param delta_t the time offset\n * @returns velocities vector\n */\nexport function calculateVelocities<T extends number[]>(delta: T, delta_t: number): T {\n  return (delta_t ? delta.map(v => v / delta_t) : Array(delta.length).fill(0)) as T\n}\n\n/**\n * Calculates distance\n * @param movement the difference between current and initial vectors\n * @returns distance\n */\nexport function calculateDistance(movement: number[]): number {\n  return Math.hypot(...movement)\n}\n\n/**\n * Calculates direction\n * @template T the expected vector type\n * @param delta\n * @param len\n * @returns direction\n */\nexport function calculateDirection<T extends number[]>(delta: T, len?: number): T {\n  len = len || Math.hypot(...delta) || 1\n  return delta.map(v => v / len!) as T\n}\n\ninterface Kinematics<T extends number[]> {\n  velocities: T\n  velocity: number\n  distance: number\n  direction: T\n}\n\n/**\n * Calculates all kinematics\n * @template T the expected vector type\n * @param movement the difference between current and initial vectors\n * @param delta the difference between current and previous vectors\n * @param delta_t the time difference between current and previous timestamps\n * @returns all kinematics\n */\nexport function calculateAllKinematics<T extends number[]>(movement: T, delta: T, delta_t: number): Kinematics<T> {\n  const len = Math.hypot(...delta)\n\n  return {\n    velocities: calculateVelocities(delta, delta_t),\n    velocity: calculateVelocity(delta, delta_t, len),\n    distance: calculateDistance(movement),\n    direction: calculateDirection(delta, len),\n  }\n}\n\nexport function getIntentional(movement: number, threshold: number): number | false {\n  const abs = Math.abs(movement)\n  return abs >= threshold ? Math.sign(movement) * threshold : false\n}\n\nfunction minMax(value: number, min: number, max: number) {\n  return Math.max(min, Math.min(value, max))\n}\n\n// Based on @aholachek ;)\n// https://twitter.com/chpwn/status/285540192096497664\n// iOS constant = 0.55\n\n// https://medium.com/@nathangitter/building-fluid-interfaces-ios-swift-9732bb934bf5\nfunction rubberband2(distance: number, constant: number) {\n  // default constant from the article is 0.7\n  return Math.pow(distance, constant * 5)\n}\n\nfunction rubberband(distance: number, dimension: number, constant: number) {\n  if (dimension === 0 || Math.abs(dimension) === Infinity) return rubberband2(distance, constant)\n  return (distance * dimension * constant) / (dimension + constant * distance)\n}\n\nexport function rubberbandIfOutOfBounds(position: number, min: number, max: number, constant = 0.15) {\n  if (constant === 0) return minMax(position, min, max)\n\n  if (position < min) {\n    return -rubberband(min - position, max - min, constant) + min\n  }\n  if (position > max) {\n    return rubberband(position - max, max - min, constant) + max\n  }\n  return position\n}\n","import { Fn, Vector2 } from '../types'\n\n// blank function\nexport function noop() {}\n// returns a function that chains all functions given as parameters\nexport const chainFns = (...fns: Fn[]): Fn => (...args: any[]) => fns.forEach(fn => fn(...args))\n\nexport const def = {\n  array: <T>(value: T | T[]): T[] => (Array.isArray(value) ? value : [value, value]),\n  withDefault: <T>(value: T | undefined, defaultIfUndefined: T): T => (value !== void 0 ? value : defaultIfUndefined),\n}\n\nexport function matchKeysFromObject<T extends object, K extends object>(obj: T, matchingObject: K): Partial<T> {\n  const o: Partial<T> = {}\n  Object.entries(obj).forEach(\n    ([key, value]) => (value !== void 0 || key in matchingObject) && (o[key as keyof T] = value)\n  )\n  return o\n}\n\nexport function valueFn(v: Vector2 | (() => Vector2)) {\n  return typeof v === 'function' ? v() : v\n}\n","import { noop } from './utils'\nimport { CommonGestureState, Coordinates, State, DistanceAngle, Vector2 } from '../types'\n\nexport function getInitialState(): State {\n  // common initial state for all gestures\n  const initialCommon: CommonGestureState = {\n    _active: false,\n    _blocked: false,\n    _intentional: [false, false],\n    _movement: [0, 0],\n    _initial: [0, 0],\n    event: undefined,\n    // currentTarget: undefined,\n    // pointerId: undefined,\n    values: [0, 0],\n    velocities: [0, 0],\n    delta: [0, 0],\n    movement: [0, 0],\n    offset: [0, 0],\n    lastOffset: [0, 0],\n    direction: [0, 0],\n    initial: [0, 0],\n    previous: [0, 0],\n    first: false,\n    last: false,\n    active: false,\n    timeStamp: 0,\n    startTime: 0,\n    elapsedTime: 0,\n    cancel: noop,\n    canceled: false,\n    memo: undefined,\n    args: undefined,\n  }\n\n  // initial state for coordinates-based gestures\n  const initialCoordinates: Coordinates = {\n    axis: undefined,\n    xy: [0, 0] as Vector2,\n    vxvy: [0, 0] as Vector2,\n    velocity: 0,\n    distance: 0,\n  }\n\n  // initial state for distance and angle-based gestures (pinch)\n  const initialDistanceAngle: DistanceAngle = {\n    da: [0, 0] as Vector2,\n    vdva: [0, 0] as Vector2,\n    origin: undefined,\n    turns: 0,\n  }\n\n  // initial state object (used by the gesture controller)\n  return {\n    shared: {\n      hovering: false,\n      scrolling: false,\n      wheeling: false,\n      dragging: false,\n      moving: false,\n      pinching: false,\n      touches: 0,\n      buttons: 0,\n      down: false,\n      shiftKey: false,\n      altKey: false,\n      metaKey: false,\n      ctrlKey: false,\n    },\n    drag: {\n      ...initialCommon,\n      ...initialCoordinates,\n      _isTap: true,\n      _delayedEvent: false,\n      tap: false,\n      swipe: [0, 0],\n    },\n    pinch: { ...initialCommon, ...initialDistanceAngle },\n    wheel: { ...initialCommon, ...initialCoordinates },\n    move: { ...initialCommon, ...initialCoordinates },\n    scroll: { ...initialCommon, ...initialCoordinates },\n  }\n}\n","import { Fn, EventOptions, UseGestureEvent, Vector2, WebKitGestureEvent } from '../types'\n\nconst isBrowser = typeof window !== 'undefined'\n\nexport const supportsTouchEvents = () => isBrowser && window.ontouchstart === null\n\nconst setListeners = (add: boolean) => (el: EventTarget, listeners: [string, Fn][], options: EventOptions): void => {\n  const action = add ? 'addEventListener' : 'removeEventListener'\n  listeners.forEach(([eventName, fn]) => el[action](eventName, fn, options))\n}\n\n/**\n * Whether the browser supports GestureEvent (ie Safari)\n * @returns true if the browser supports gesture event\n */\nexport function supportsGestureEvents(): boolean {\n  try {\n    // TODO [TS] possibly find GestureEvent definitions?\n    // @ts-ignore: no type definitions for webkit GestureEvents\n    return 'constructor' in GestureEvent\n  } catch (e) {\n    return false\n  }\n}\n\nexport const addListeners = setListeners(true)\nexport const removeListeners = setListeners(false)\n\ninterface ModifierKeys {\n  shiftKey: boolean\n  altKey: boolean\n  metaKey: boolean\n  ctrlKey: boolean\n}\n\n/**\n * Gets modifier keys from event\n * @param event\n * @returns modifier keys\n */\nexport function getModifierKeys(event: UseGestureEvent): ModifierKeys {\n  const { shiftKey, altKey, metaKey, ctrlKey } = event\n  return { shiftKey, altKey, metaKey, ctrlKey }\n}\n\nfunction getTouchEvents(event: UseGestureEvent) {\n  if ('touches' in event) {\n    const { touches, changedTouches } = event\n    return touches.length > 0 ? touches : changedTouches\n  }\n  return null\n}\n\nexport function getGenericEventData(event: React.MouseEvent | React.TouchEvent | React.PointerEvent) {\n  const buttons = 'buttons' in event ? event.buttons : 0\n  const touchEvents = getTouchEvents(event)\n  const touches = (touchEvents && touchEvents.length) || 0\n  const down = touches > 0 || buttons > 0\n  return { touches, down, buttons, ...getModifierKeys(event) }\n}\n\ntype Values = { values: Vector2 }\n\n/**\n * Gets scroll event values\n * @param event\n * @returns scroll event values\n */\nexport function getScrollEventValues(event: UseGestureEvent): Values {\n  // If the currentTarget is the window then we return the scrollX/Y position.\n  // If not (ie the currentTarget is a DOM element), then we return scrollLeft/Top\n  const { scrollX, scrollY, scrollLeft, scrollTop } = event.currentTarget as Element & Window\n  return { values: [scrollX || scrollLeft || 0, scrollY || scrollTop || 0] }\n}\n\n/**\n * Gets wheel event values.\n * @param event\n * @returns wheel event values\n */\nexport function getWheelEventValues(event: UseGestureEvent<React.WheelEvent>): Values {\n  const { deltaX, deltaY } = event\n  //TODO implement polyfill ?\n  // https://developer.mozilla.org/en-US/docs/Web/Events/wheel#Polyfill\n  return { values: [deltaX, deltaY] }\n}\n\n/**\n * Gets pointer event values.\n * @param event\n * @returns pointer event values\n */\nexport function getPointerEventValues(event: React.MouseEvent | React.TouchEvent | React.PointerEvent): Values {\n  const touchEvents = getTouchEvents(event)\n  const { clientX, clientY } = touchEvents ? touchEvents[0] : (event as React.PointerEvent)\n  return { values: [clientX, clientY] }\n}\n\nconst WEBKIT_DISTANCE_SCALE_FACTOR = 260\n\n/**\n * Gets webkit gesture event values.\n * @param event\n * @returns webkit gesture event values\n */\nexport function getWebkitGestureEventValues(event: WebKitGestureEvent): Values {\n  return { values: [event.scale * WEBKIT_DISTANCE_SCALE_FACTOR, event.rotation] as Vector2 }\n}\n\n/**\n * Gets two touches event data\n * @param event\n * @returns two touches event data\n */\nexport function getTwoTouchesEventData(event: React.TouchEvent) {\n  const { touches } = event\n  const dx = touches[1].clientX - touches[0].clientX\n  const dy = touches[1].clientY - touches[0].clientY\n\n  const values: Vector2 = [Math.hypot(dx, dy), -(Math.atan2(dx, dy) * 180) / Math.PI]\n  const origin: Vector2 = [(touches[1].clientX + touches[0].clientX) / 2, (touches[1].clientY + touches[0].clientY) / 2]\n\n  return { values, origin }\n}\n","import {\n  StateKey,\n  State,\n  Fn,\n  ReactEventHandlerKey,\n  ReactEventHandlers,\n  InternalConfig,\n  InternalHandlers,\n} from './types'\nimport { getInitialState } from './utils/state'\nimport { addListeners, removeListeners } from './utils/event'\nimport { chainFns } from './utils/utils'\n\ntype GestureTimeouts = Partial<{ [stateKey in StateKey]: number }>\ntype WindowListeners = Partial<{ [stateKey in StateKey]: [string, Fn][] }>\ntype Bindings = Partial<{ [eventName in ReactEventHandlerKey]: Fn[] }>\n\n/**\n * The controller will keep track of the state for all gestures and also keep\n * track of timeouts, and window listeners.\n *\n * @template BinderType the type the bind function should return\n */\nexport default class Controller {\n  public config!: InternalConfig\n  public handlers!: Partial<InternalHandlers>\n  public state: State = getInitialState() // state for all gestures\n  public timeouts: GestureTimeouts = {} // keeping track of timeouts for debounced gestures (such as move, scroll, wheel)\n  private domListeners: [string, Fn][] = [] // when config.domTarget is set, we attach events directly to the dom\n  private windowListeners: WindowListeners = {} // keeps track of window listeners added by gestures (drag only at the moment)\n  private bindings: Bindings = {} // an object holding the handlers associated to the gestures\n\n  /**\n   * Function ran on component unmount: cleans timeouts and removes dom listeners set by the bind function.\n   */\n  public clean = (): void => {\n    this.resetBindings()\n    Object.values(this.timeouts).forEach(clearTimeout)\n    Object.keys(this.windowListeners).forEach(stateKey => this.removeWindowListeners(stateKey as StateKey))\n  }\n\n  /**\n   * Function run every time the bind function is run (ie on every render).\n   * Resets the binding object and remove dom listeners attached to config.domTarget\n   */\n  public resetBindings = (): void => {\n    this.bindings = {}\n    const domTarget = this.getDomTarget()\n    if (domTarget) {\n      removeListeners(domTarget, this.domListeners, this.config.eventOptions)\n      this.domListeners = []\n    }\n  }\n\n  /**\n   * Returns the domTarget element and parses a ref if needed.\n   */\n  private getDomTarget = (): EventTarget | null | undefined => {\n    const { domTarget } = this.config\n    return domTarget && 'current' in domTarget ? domTarget.current : domTarget\n  }\n\n  /**\n   * Commodity function to let recognizers simply add listeners to config.window.\n   */\n  public addWindowListeners = (stateKey: StateKey, listeners: [string, Fn][]): void => {\n    if (!this.config.window) return\n    // we use this.windowListeners to keep track of the listeners we add\n    this.windowListeners[stateKey] = listeners\n    addListeners(this.config.window, listeners, this.config.eventOptions)\n  }\n\n  /**\n   * Commodity function to let recognizers simply remove listeners to config.window.\n   */\n  public removeWindowListeners = (stateKey: StateKey): void => {\n    if (!this.config.window) return\n    const listeners = this.windowListeners[stateKey]\n    if (listeners) {\n      removeListeners(this.config.window, listeners, this.config.eventOptions)\n      delete this.windowListeners[stateKey]\n    }\n  }\n\n  /**\n   * When config.domTarget is set, this function will add dom listeners to it\n   */\n  public addDomTargetListeners = (target: EventTarget): void => {\n    /** We iterate on the entries of this.binding for each event, then we chain\n     * the array of functions mapped to it and push them to this.domListeners\n     */\n    Object.entries(this.bindings).forEach(([event, fns]) => {\n      this.domListeners.push([event.substr(2).toLowerCase(), chainFns(...(fns as Fn[]))])\n    })\n\n    addListeners(target, this.domListeners, this.config.eventOptions)\n  }\n\n  /**\n   * this.bindings is an object which keys match ReactEventHandlerKeys.\n   * Since a recognizer might want to bind a handler function to an event key already used by a previously\n   * added recognizer, we need to make sure that each event key is an array of all the functions mapped for\n   * that key.\n   */\n  public addBindings = (eventNames: ReactEventHandlerKey | ReactEventHandlerKey[], fn: Fn): void => {\n    const eventNamesArray = !Array.isArray(eventNames) ? [eventNames] : eventNames\n    eventNamesArray.forEach(eventName => {\n      if (this.bindings[eventName]) this.bindings[eventName]!.push(fn)\n      else this.bindings[eventName] = [fn]\n    })\n  }\n\n  /**\n   * getBindings will return an object that will be bound by users\n   * to the react component they want to interact with.\n   */\n  public getBindings = (): ReactEventHandlers => {\n    const bindings: ReactEventHandlers = {}\n    const { captureString } = this.config\n\n    Object.entries(this.bindings).forEach(([event, fns]) => {\n      const fnsArray = Array.isArray(fns) ? fns : [fns]\n      const key = (event + captureString) as ReactEventHandlerKey\n      bindings[key] = chainFns(...(fnsArray as Fn[]))\n    })\n\n    return bindings\n  }\n\n  public getBind = () => {\n    // If config.domTarget is set we add event listeners to it and return the clean function.\n    if (this.config.domTarget) {\n      const domTarget = this.getDomTarget()\n      domTarget && this.addDomTargetListeners(domTarget)\n      return this.clean\n    }\n\n    // If not, we return an object that contains gesture handlers mapped to react handler event keys.\n    return this.getBindings()\n  }\n}\n","import React from 'react'\nimport Controller from '../Controller'\nimport {\n  InternalConfig,\n  HookReturnType,\n  InternalHandlers,\n  RecognizerClasses,\n  GenericOptions,\n  NativeHandlersPartial,\n  ReactEventHandlerKey,\n  Fn,\n} from '../types'\n/**\n * @private\n *\n * Utility hook called by all gesture hooks and that will be responsible for the internals.\n *\n * @param {Partial<InternalHandlers>} handlers\n * @param {RecognizerClasses} classes\n * @param {InternalConfig} config\n * @param {NativeHandlersPartial} nativeHandlers - native handlers such as onClick, onMouseDown, etc.\n * @returns {(...args: any[]) => HookReturnType<Config>}\n */\nexport default function useRecognizers<Config extends Partial<GenericOptions>>(\n  handlers: Partial<InternalHandlers>,\n  classes: RecognizerClasses,\n  config: InternalConfig,\n  nativeHandlers?: NativeHandlersPartial\n): (...args: any[]) => HookReturnType<Config> {\n  const controller = React.useRef<Controller>() // The gesture controller keeping track of all gesture states\n  const nativeRefs = React.useRef<NativeHandlersPartial>()\n\n  if (!controller.current) {\n    // We only initialize the gesture controller once\n    controller.current = new Controller()\n  }\n\n  // We reassign the config and handlers to the controller on every render.\n  controller.current!.config = config\n  controller.current!.handlers = handlers\n\n  /**\n   * We also assign nativeHandlers to a ref, otherwise it they won't be refreshed\n   * on the next render.\n   */\n  nativeRefs.current = nativeHandlers\n\n  /**\n   * When the component unmounts, we run the controller clean functions that will be responsible\n   * for removing listeners, clearing timeouts etc.\n   */\n  React.useEffect(() => controller.current!.clean, [])\n\n  /**\n   * The bind function will create gesture recognizers and return the right\n   * bind object depending on whether `domTarget` was specified in the config object.\n   */\n  const [bind] = React.useState(() => (...args: any[]) => {\n    controller.current!.resetBindings()\n    classes.forEach(RecognizerClass => {\n      const recognizer = new RecognizerClass(controller.current!, args)\n      recognizer.addBindings()\n    })\n\n    if (nativeRefs.current) {\n      // we also add event bindings for native handlers\n      Object.entries(nativeRefs.current).forEach(([eventName, fn]) => {\n        // we're cheating when it comes to event type :(\n        controller.current!.addBindings(eventName as ReactEventHandlerKey, fn as Fn)\n      })\n    }\n\n    return controller.current!.getBind() as HookReturnType<Config>\n  })\n\n  return bind\n}\n","import Controller from '../Controller'\nimport {\n  StateKey,\n  SharedGestureState,\n  Fn,\n  UseGestureEvent,\n  IngKey,\n  InternalConfig,\n  GestureState,\n  PartialGestureState,\n  Vector2,\n  FalseOrNumber,\n  FullGestureState,\n} from '../types'\nimport { getInitialState } from '../utils/state'\nimport { subV, addV, getIntentional, rubberbandIfOutOfBounds } from '../utils/math'\nimport { valueFn } from '../utils/utils'\n\n/**\n * @private\n * Recognizer abstract class.\n *\n * @protected\n * @abstract\n * @type {StateKey<T>} whether the Recognizer should deal with coordinates or distance / angle\n */\nexport default abstract class Recognizer<T extends StateKey> {\n  protected abstract ingKey: IngKey // dragging, scrolling, etc.\n\n  /**\n   * Creates an instance of a gesture recognizer.\n   * @param stateKey drag, move, pinch, etc.\n   * @param controller the controller attached to the gesture\n   * @param [args] the args that should be passed to the gesture handler\n   */\n  constructor(\n    protected readonly stateKey: T,\n    protected readonly controller: Controller,\n    protected readonly args: any[] = []\n  ) {}\n\n  // Returns the gesture config\n  protected get config(): NonNullable<InternalConfig[T]> {\n    return this.controller.config[this.stateKey]!\n  }\n\n  // Is the gesture enabled\n  protected get enabled(): boolean {\n    return this.controller.config.enabled && this.config.enabled\n  }\n\n  // Returns the controller state for a given gesture\n  protected get state(): GestureState<T> {\n    return this.controller.state[this.stateKey]\n  }\n\n  // Returns the gesture handler\n  protected get handler() {\n    return this.controller.handlers[this.stateKey]!\n  }\n\n  // Conveninence method to update the shared state\n  protected updateSharedState(sharedState: Partial<SharedGestureState> | null) {\n    Object.assign(this.controller.state.shared, sharedState)\n  }\n\n  // Conveninence method to update the gesture state\n  protected updateGestureState(gestureState: PartialGestureState<T> | null) {\n    Object.assign(this.state, gestureState)\n  }\n\n  // Convenience method to set a timeout for a given gesture\n  protected setTimeout = (callback: (...args: any[]) => void, ms: number = 140, ...args: any[]): void => {\n    this.controller.timeouts[this.stateKey] = window.setTimeout(callback, ms, ...args)\n  }\n\n  // Convenience method to clear a timeout for a given gesture\n  protected clearTimeout = () => {\n    clearTimeout(this.controller.timeouts[this.stateKey])\n  }\n\n  // Convenience method to add window listeners for a given gesture\n  protected addWindowListeners = (listeners: [string, Fn][]) => {\n    this.controller.addWindowListeners(this.stateKey, listeners)\n  }\n\n  // Convenience method to remove window listeners for a given gesture\n  protected removeWindowListeners = () => {\n    this.controller.removeWindowListeners(this.stateKey)\n  }\n\n  /**\n   * Utility function to get kinematics of the gesture.\n   *\n   * @abstract\n   * @values - values we want to calculate the kinematics from\n   * @event - the pointer event\n   * @returns - set of values including movement, velocity, velocities, distance and direction\n   */\n  protected abstract getKinematics(values: Vector2, event: UseGestureEvent): PartialGestureState<T>\n\n  protected abstract mapStateValues(state: GestureState<T>): PartialGestureState<T>\n\n  // Should return the bindings to be added for a given gesture\n  public abstract addBindings(): void\n\n  /**\n   * Returns a generic, common payload for all gestures from an event.\n   *\n   * @param {UseGestureEvent} event\n   * @param {boolean} [isStartEvent]\n   * @returns - the generic gesture payload\n   */\n  protected getGenericPayload(event: UseGestureEvent, isStartEvent?: boolean) {\n    const { timeStamp } = event\n    const { values, startTime } = this.state\n\n    return {\n      event,\n      timeStamp,\n      elapsedTime: isStartEvent ? 0 : timeStamp - startTime!,\n      args: this.args,\n      previous: values,\n    }\n  }\n  /**\n   * Returns the reinitialized start state for the gesture.\n   * Should be common to all gestures.\n   *\n   * @param {Vector2} values\n   * @param {UseGestureEvent} event\n   * @returns - the start state for the gesture\n   */\n  protected getStartGestureState = (values: Vector2, event: UseGestureEvent) => {\n    return {\n      ...getInitialState()[this.stateKey],\n      _active: true,\n      values,\n      initial: values,\n      offset: this.state.offset,\n      lastOffset: this.state.offset,\n      startTime: event.timeStamp,\n    }\n  }\n\n  /**\n   * Returns state properties depending on the movement and state.\n   *\n   * Should be overriden for custom behavior, doesn't do anything in the implementation\n   * below.\n   */\n  protected checkIntentionality(\n    _intentional: [FalseOrNumber, FalseOrNumber],\n    _movement: Vector2,\n    _state: PartialGestureState<T>\n  ): PartialGestureState<T> {\n    return { _intentional, _blocked: false } as PartialGestureState<T>\n  }\n\n  protected abstract getInternalMovement(values: Vector2, state: GestureState<T>): Vector2\n\n  /**\n   * Returns basic movement properties for the gesture based on the next values and current state.\n   */\n  protected getMovement(values: Vector2, state: GestureState<T> = this.state): PartialGestureState<T> {\n    const { initial, threshold, rubberband } = this.config\n\n    const [t0, t1] = threshold\n\n    const { _initial, _active, _intentional: intentional, lastOffset, movement: prevMovement } = state\n    let [i0, i1] = intentional\n\n    const [_m0, _m1] = this.getInternalMovement(values, state)\n\n    /**\n     * For both dimensions of the gesture, check its intentionality on each frame.\n     */\n    if (i0 === false) {\n      i0 = getIntentional(_m0, t0)\n    }\n    if (i1 === false) {\n      i1 = getIntentional(_m1, t1)\n    }\n\n    // Get gesture specific state properties based on intentionality and movement.\n    const intentionalityCheck = this.checkIntentionality([i0, i1], [_m0, _m1], state)\n\n    const { _intentional, _blocked } = intentionalityCheck\n    const [_i0, _i1] = _intentional!\n    const _movement = [_m0, _m1]\n\n    if (_i0 !== false && intentional[0] === false) _initial[0] = valueFn(initial)[0]\n    if (_i1 !== false && intentional[1] === false) _initial[1] = valueFn(initial)[1]\n\n    /**\n     * If the gesture has been blocked (from gesture specific checkIntentionality),\n     * stop right there.\n     */\n    if (_blocked) return { ...intentionalityCheck, _movement }\n\n    /**\n     * The movement sent to the handler has 0 in its dimensions when intentionality is false.\n     * It is calculated from the actual movement minus the threshold.\n     */\n    let movement = [\n      _i0 !== false ? _m0 - _i0 : valueFn(initial)[0],\n      _i1 !== false ? _m1 - _i1 : valueFn(initial)[1],\n    ] as Vector2\n    const offset = addV(movement, lastOffset)\n\n    /**\n     * Rubberband should be 0 when the gesture is no longer active, so that movement\n     * and offset can return within their bounds.\n     */\n    const _rubberband: Vector2 = _active ? rubberband : [0, 0]\n    movement = this.rubberband(addV(movement, _initial), _rubberband) // rubberbanded movement\n\n    return {\n      ...intentionalityCheck,\n      _initial,\n      _movement,\n      movement,\n      offset: this.rubberband(offset, _rubberband), // rubberbanded offset\n      delta: subV(movement, prevMovement),\n    } as PartialGestureState<T>\n  }\n\n  // Runs rubberband on a vector\n  protected rubberband = (vector: Vector2, rubberband: Vector2): Vector2 => {\n    const { bounds } = this.config\n\n    /**\n     * [x, y]: [rubberband(x, min, max), rubberband(y, min, max)]\n     */\n    return vector.map((v, i) => rubberbandIfOutOfBounds(v, bounds[i][0], bounds[i][1], rubberband[i])) as Vector2\n  }\n\n  // Cleans the gesture. Can be overriden by gestures.\n  protected clean() {\n    this.clearTimeout()\n    this.removeWindowListeners()\n  }\n\n  /**\n   * Fires the gesture handler\n   *\n   * @param {boolean} [forceFlag] - if true, then the handler will fire even if the gesture is not intentional\n   */\n  protected fireGestureHandler = (forceFlag?: boolean): FullGestureState<T> | null => {\n    /**\n     * If the gesture has been blocked (this can happen when the gesture has started in an unwanted direction),\n     * clean everything and don't do anything.\n     */\n    if (this.state._blocked) {\n      this.state._active = false\n      this.clean()\n      return null\n    }\n\n    // If the gesture has no intentional dimension, don't do fire the handler.\n    const [intentionalX, intentionalY] = this.state._intentional\n    if (!forceFlag && intentionalX === false && intentionalY === false) return null\n\n    const { _active, active } = this.state\n\n    this.state.active = _active\n    this.state.first = _active && !active // `first` is true when the gesture becomes active\n    this.state.last = !_active // `last` is true when the gesture becomes inactive\n\n    this.controller.state.shared[this.ingKey] = _active // Sets dragging, pinching, etc. to the gesture active state\n\n    const state = {\n      ...this.controller.state.shared,\n      ...this.state,\n      ...this.mapStateValues(this.state), // Sets xy or da to the gesture state values\n    } as FullGestureState<T>\n\n    // @ts-ignore\n    const newMemo = this.handler(state)\n\n    // Sets memo to the returned value of the handler (unless it's not undefined)\n    this.state.memo = newMemo !== void 0 ? newMemo : this.state.memo\n\n    // Cleans the gesture when the gesture is no longer active.\n    if (!_active) this.clean()\n\n    return state\n  }\n}\n","import Recognizer from './Recognizer'\nimport { calculateAllKinematics, subV } from '../utils/math'\nimport { Vector2, UseGestureEvent, PartialGestureState, FalseOrNumber, GestureState, CoordinatesKey } from '../types'\n\n/**\n * @private\n * Abstract class for coordinates-based gesture recongizers\n * @abstract\n * @class CoordinatesRecognizer\n * @extends {Recognizer<T>}\n * @template T\n */\nexport default abstract class CoordinatesRecognizer<T extends CoordinatesKey> extends Recognizer<T> {\n  /**\n   * Returns the real movement (without taking intentionality into acount)\n   */\n  protected getInternalMovement(values: Vector2, state: GestureState<T>): Vector2 {\n    return subV(values, state.initial)\n  }\n\n  /**\n   * In coordinates-based gesture, this function will detect the first intentional axis,\n   * lock the gesture axis if lockDirection is specified in the config, block the gesture\n   * if the first intentional axis doesn't match the specified axis in config.\n   *\n   * @param {[FalseOrNumber, FalseOrNumber]} _intentional\n   * @param {Vector2} _movement\n   * @param {PartialGestureState<T>} state\n   */\n  protected checkIntentionality(\n    _intentional: [FalseOrNumber, FalseOrNumber],\n    _movement: Vector2,\n    state: PartialGestureState<T>\n  ): PartialGestureState<T> {\n    let [_ix, _iy] = _intentional\n    const intentionalMovement = _ix !== false || _iy !== false\n    let { axis } = state\n    let _blocked = false\n\n    // If the movement is intentional, we can compute axis.\n    if (intentionalMovement) {\n      const [absX, absY] = _movement.map(Math.abs)\n\n      const { axis: configAxis, lockDirection } = this.config\n\n      // We make sure we only set axis value if it hadn't been detected before.\n      axis = axis || (absX > absY ? 'x' : absX < absY ? 'y' : undefined)\n      if (!!configAxis || lockDirection) {\n        if (!!axis) {\n          // If the detected axis doesn't match the config axis we block the gesture\n          if (!!configAxis && axis !== configAxis) _blocked = true\n          else {\n            // Otherwise we prevent the gesture from updating the unwanted axis.\n            const lockedIndex = axis === 'x' ? 1 : 0\n            _intentional![lockedIndex] = false\n          }\n        } else {\n          // Until we've detected the axis, we prevent the hnadler from updating.\n          _intentional = [false, false]\n        }\n      }\n    }\n\n    return { _intentional, _blocked, axis } as PartialGestureState<T>\n  }\n\n  getKinematics(values: Vector2, event: UseGestureEvent): PartialGestureState<T> {\n    const { timeStamp } = this.state\n\n    const movementDetection = this.getMovement(values, this.state)\n    const { _blocked, delta, movement } = movementDetection\n\n    if (_blocked) return movementDetection\n\n    const delta_t = event.timeStamp - timeStamp!\n    const kinematics = calculateAllKinematics(movement!, delta!, delta_t)\n\n    return {\n      values,\n      delta,\n      ...movementDetection,\n      ...kinematics,\n    }\n  }\n\n  protected mapStateValues(state: GestureState<T>): PartialGestureState<T> {\n    return { xy: state.values, vxvy: state.velocities } as PartialGestureState<T>\n  }\n}\n","import { PointerEvent } from 'react'\nimport CoordinatesRecognizer from './CoordinatesRecognizer'\nimport Controller from '../Controller'\nimport { UseGestureEvent, Fn, IngKey } from '../types'\nimport { noop } from '../utils/utils'\nimport { getPointerEventValues, getGenericEventData } from '../utils/event'\nimport { calculateDistance } from '../utils/math'\n\nconst TAP_DISTANCE_THRESHOLD = 3\nconst SWIPE_MAX_ELAPSED_TIME = 220\n\nexport default class DragRecognizer extends CoordinatesRecognizer<'drag'> {\n  ingKey = 'dragging' as IngKey\n\n  constructor(controller: Controller, args: any[]) {\n    super('drag', controller, args)\n  }\n\n  private dragShouldStart = (event: UseGestureEvent) => {\n    const { touches } = getGenericEventData(event)\n    return this.enabled && touches < 2\n  }\n\n  private setPointers = (event: UseGestureEvent) => {\n    const { currentTarget, pointerId } = event as PointerEvent\n    // @ts-ignore\n    if (currentTarget) currentTarget.setPointerCapture(pointerId)\n    this.updateGestureState({ currentTarget, pointerId })\n  }\n\n  private removePointers = () => {\n    const { currentTarget, pointerId } = this.state\n    // @ts-ignore\n    if (currentTarget) currentTarget.releasePointerCapture(pointerId)\n  }\n\n  private setListeners = () => {\n    this.removeWindowListeners()\n    const dragListeners: [string, Fn][] = [\n      ['touchmove', this.onDragChange],\n      ['touchend', this.onDragEnd],\n      ['touchcancel', this.onDragEnd],\n      ['mousemove', this.onDragChange],\n      ['mouseup', this.onDragEnd],\n    ]\n    this.addWindowListeners(dragListeners)\n  }\n\n  onDragStart = (event: UseGestureEvent): void => {\n    if (!this.dragShouldStart(event)) return\n    // if pointers events\n    if (this.controller.config.pointer) this.setPointers(event)\n    else this.setListeners()\n\n    if (this.config.delay > 0) {\n      this.state._delayedEvent = true\n      if (typeof event.persist === 'function') event.persist()\n      this.setTimeout(() => this.startDrag(event), this.config.delay)\n    } else {\n      this.startDrag(event)\n    }\n  }\n\n  startDrag(event: UseGestureEvent) {\n    const { values } = getPointerEventValues(event)\n\n    this.updateSharedState(getGenericEventData(event))\n\n    const startState = {\n      ...this.getStartGestureState(values, event),\n      ...this.getGenericPayload(event, true),\n    }\n\n    this.updateGestureState({\n      ...startState,\n      ...this.getMovement(values, startState),\n      cancel: () => this.onCancel(),\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onDragChange = (event: UseGestureEvent): void => {\n    const { canceled } = this.state\n    if (canceled) return\n\n    if (!this.state._active) {\n      if (this.state._delayedEvent) {\n        this.clearTimeout()\n        this.startDrag(event)\n      }\n      return\n    }\n\n    const genericEventData = getGenericEventData(event)\n\n    if (!genericEventData.down) {\n      this.onDragEnd(event)\n      return\n    }\n\n    this.updateSharedState(genericEventData)\n\n    const { values } = getPointerEventValues(event)\n    const kinematics = this.getKinematics(values, event)\n\n    let { _isTap } = this.state\n    if (_isTap && calculateDistance(kinematics._movement!) >= TAP_DISTANCE_THRESHOLD) _isTap = false\n\n    this.updateGestureState({\n      ...this.getGenericPayload(event),\n      ...kinematics,\n      _isTap,\n      cancel: () => this.onCancel(),\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onDragEnd = (event: UseGestureEvent): void => {\n    this.state._active = false\n    this.updateSharedState({ down: false, buttons: 0, touches: 0 })\n\n    const {\n      _isTap,\n      values,\n      velocities: [vx, vy],\n      movement: [mx, my],\n      _intentional: [ix, iy],\n    } = this.state\n\n    const endState = {\n      ...this.getGenericPayload(event),\n      ...this.getMovement(values),\n    }\n\n    const { elapsedTime } = endState\n\n    const {\n      swipeVelocity: [svx, svy],\n      swipeDistance: [sx, sy],\n    } = this.config\n\n    const swipe: [number, number] = [0, 0]\n\n    if (elapsedTime < SWIPE_MAX_ELAPSED_TIME) {\n      if (ix !== false && Math.abs(vx) > svx && Math.abs(mx) > sx) swipe[0] = Math.sign(vx)\n      if (iy !== false && Math.abs(vy) > svy && Math.abs(my) > sy) swipe[1] = Math.sign(vy)\n    }\n\n    this.updateGestureState({\n      event,\n      ...endState,\n      tap: _isTap,\n      swipe,\n    })\n    this.fireGestureHandler(this.config.filterTaps && this.state._isTap)\n  }\n\n  clean = (): void => {\n    super.clean()\n    this.state._delayedEvent = false\n\n    if (this.controller.config.pointer) this.removePointers()\n  }\n\n  onCancel = (): void => {\n    this.updateGestureState({ canceled: true, cancel: noop })\n    this.state._active = false\n    this.updateSharedState({ down: false, buttons: 0, touches: 0 })\n    requestAnimationFrame(() => this.fireGestureHandler())\n  }\n\n  addBindings(): void {\n    if (this.controller.config.pointer) {\n      this.controller.addBindings('onPointerDown', this.onDragStart)\n      this.controller.addBindings('onPointerMove', this.onDragChange)\n      this.controller.addBindings(['onPointerUp', 'onPointerCancel'], this.onDragEnd)\n    } else {\n      this.controller.addBindings(['onTouchStart', 'onMouseDown'], this.onDragStart)\n    }\n  }\n}\n","import { def, matchKeysFromObject } from './utils'\nimport {\n  Vector2,\n  GenericOptions,\n  InternalGenericOptions,\n  DragConfig,\n  Tuple,\n  GestureOptions,\n  DragOptions,\n  InternalDragOptions,\n  InternalGestureOptions,\n  CoordinatesConfig,\n  CoordinatesOptions,\n  InternalCoordinatesOptions,\n  DistanceAngleConfig,\n  InternalDistanceAngleOptions,\n} from '../types'\n\nconst DEFAULT_DRAG_DELAY = 180\nconst DEFAULT_RUBBERBAND = 0.15\n\nfunction getWindow() {\n  return typeof window !== 'undefined' ? window : undefined\n}\n\n/**\n * @private\n *\n * Returns the internal generic option object.\n *\n * @param {Partial<GenericOptions>} [config={}]\n * @returns {InternalGenericOptions}\n */\nexport function getInternalGenericOptions(config: Partial<GenericOptions> = {}): InternalGenericOptions {\n  const defaultOptions: GenericOptions = {\n    domTarget: undefined,\n    eventOptions: { passive: true, capture: false, pointer: false },\n    window: getWindow(),\n    enabled: true,\n  }\n\n  const { eventOptions: defaultEventOptions, window: defaultWindow, ...restDefault } = defaultOptions\n  const { eventOptions, window, ...restConfig } = config\n  const { passive, capture, pointer } = { ...defaultEventOptions, ...eventOptions }\n\n  return {\n    ...restDefault,\n    ...restConfig,\n    window: window || defaultWindow,\n    // passive is always true if there's no domTarget\n    eventOptions: { passive: !config.domTarget || !!passive, capture: !!capture },\n    captureString: capture ? 'Capture' : '',\n    pointer: !!pointer,\n  }\n}\n\nexport function getInternalGestureOptions(gestureConfig: Partial<GestureOptions>): InternalGestureOptions {\n  const defaultGestureOptions: GestureOptions = {\n    enabled: true,\n    initial: [0, 0],\n    threshold: undefined,\n    rubberband: 0,\n  }\n\n  const config = { ...defaultGestureOptions, ...gestureConfig }\n  let { threshold, rubberband, enabled, initial } = config\n\n  if (typeof rubberband === 'boolean') rubberband = rubberband ? DEFAULT_RUBBERBAND : 0\n  if (threshold === void 0) threshold = 0\n\n  return {\n    enabled,\n    initial,\n    threshold: def.array(threshold) as Vector2,\n    rubberband: def.array(rubberband) as Vector2,\n  }\n}\n\nexport function getInternalCoordinatesOptions(coordinatesConfig: CoordinatesConfig = {}): InternalCoordinatesOptions {\n  const defaultCoordinatesOptions: CoordinatesOptions = {\n    lockDirection: false,\n    axis: undefined,\n    bounds: undefined,\n  }\n\n  const { axis, lockDirection, bounds = {}, ...internalOptions } = coordinatesConfig\n\n  const boundsArray = [\n    [def.withDefault(bounds.left, -Infinity), def.withDefault(bounds.right, Infinity)],\n    [def.withDefault(bounds.top, -Infinity), def.withDefault(bounds.bottom, Infinity)],\n  ]\n\n  return {\n    ...getInternalGestureOptions(internalOptions),\n    ...defaultCoordinatesOptions,\n    ...matchKeysFromObject({ axis, lockDirection }, coordinatesConfig),\n    bounds: boundsArray as Tuple<Vector2>,\n  }\n}\n\nexport function getInternalDistanceAngleOptions(\n  distanceAngleConfig: DistanceAngleConfig = {}\n): InternalDistanceAngleOptions {\n  const { distanceBounds = {}, angleBounds = {}, ...internalOptions } = distanceAngleConfig\n\n  const boundsArray = [\n    [def.withDefault(distanceBounds.min, -Infinity), def.withDefault(distanceBounds.max, Infinity)],\n    [def.withDefault(angleBounds.min, -Infinity), def.withDefault(angleBounds.max, Infinity)],\n  ]\n\n  return {\n    ...getInternalGestureOptions(internalOptions),\n    bounds: boundsArray as Tuple<Vector2>,\n  }\n}\n\nexport function getInternalDragOptions(dragConfig: DragConfig = {}): InternalDragOptions {\n  const defaultDragOptions: DragOptions = {\n    filterTaps: false,\n    swipeVelocity: 0.5,\n    swipeDistance: 60,\n    delay: false,\n  }\n\n  let { enabled, threshold, bounds, rubberband, initial, ...dragOptions } = dragConfig\n  let { swipeVelocity, swipeDistance, delay, filterTaps, axis, lockDirection } = {\n    ...defaultDragOptions,\n    ...dragOptions,\n  }\n\n  if (threshold === void 0) {\n    threshold = Math.max(0, filterTaps ? 3 : 0, lockDirection || axis ? 1 : 0)\n  } else {\n    filterTaps = true\n  }\n\n  const internalCoordinatesOptions = getInternalCoordinatesOptions(\n    matchKeysFromObject({ enabled, threshold, bounds, rubberband, axis, lockDirection, initial }, dragConfig)\n  )\n\n  return {\n    ...internalCoordinatesOptions,\n    filterTaps: filterTaps || internalCoordinatesOptions.threshold[0] + internalCoordinatesOptions.threshold[1] > 0,\n    swipeVelocity: def.array(swipeVelocity) as Vector2,\n    swipeDistance: def.array(swipeDistance) as Vector2,\n    delay: typeof delay === 'number' ? delay : delay ? DEFAULT_DRAG_DELAY : 0,\n  }\n}\n","import useRecognizers from './useRecognizers'\nimport DragRecognizer from '../recognizers/DragRecognizer'\nimport { Handler, InternalConfig, HookReturnType, UseDragConfig } from '../types'\nimport { getInternalGenericOptions, getInternalDragOptions } from '../utils/config'\n\n/**\n * @public\n *\n * Drag hook.\n *\n * @param {Handler<'drag'>} handler - the function fired every time the drag gesture updates\n * @param {(Config | {})} [config={}] - the config object including generic options and drag options\n * @returns {(...args: any[]) => HookReturnType<Config>}\n */\nexport function useDrag<Config extends UseDragConfig>(\n  handler: Handler<'drag'>,\n  config: Config | {} = {}\n): (...args: any[]) => HookReturnType<Config> {\n  const { domTarget, eventOptions, window, ...drag } = config as UseDragConfig\n\n  /**\n   * TODO: at the moment we recompute the config object at every render\n   * this could probably be optimized\n   */\n  const mergedConfig: InternalConfig = {\n    ...getInternalGenericOptions({\n      domTarget,\n      eventOptions,\n      window,\n    }),\n    drag: getInternalDragOptions(drag),\n  }\n\n  return useRecognizers<Config>({ drag: handler }, [DragRecognizer], mergedConfig)\n}\n","import Recognizer from './Recognizer'\nimport { calculateAllKinematics } from '../utils/math'\nimport { Vector2, UseGestureEvent, PartialGestureState, DistanceAngleKey, GestureState } from '../types'\n\n/**\n * @private\n * Abstract class for distance/angle-based gesture recongizers\n * @abstract\n * @class DistanceAngleRecognizer\n * @extends {Recognizer<T>}\n * @template T\n */\nexport default abstract class DistanceAngleRecognizer<T extends DistanceAngleKey> extends Recognizer<T> {\n  /**\n   * Returns the real movement (without taking intentionality into acount)\n   */\n  protected getInternalMovement([d, a]: [number, number?], state: GestureState<T>): Vector2 {\n    const { values: da, turns, initial } = state\n\n    // angle might not be defined when ctrl wheel is used for zoom only\n    // in that case we set it to the previous angle value\n    a = a !== void 0 ? a : da[1]\n\n    let delta_a = a - da[1]\n\n    /**\n     * The angle value might jump from 179deg to -179deg when we actually want to\n     * read 181deg to ensure continuity. To make that happen, we detect when the jump\n     * is supsiciously high (ie > 270deg) and increase the `turns` value\n     */\n    const newTurns = Math.abs(delta_a) > 270 ? turns + Math.sign(delta_a) : turns\n\n    // we update the angle difference to its corrected value\n\n    const movement_d = d - initial[0]\n    const movement_a = a - 360 * newTurns - initial[1]\n    return [movement_d, movement_a]\n  }\n\n  getKinematics(values: Vector2, event: UseGestureEvent): PartialGestureState<T> {\n    const { timeStamp, initial } = this.state\n\n    const movementDetection = this.getMovement(values, this.state)\n    const { delta, movement } = movementDetection\n\n    const turns = (values[1] - movement![1] - initial[1]) / 360\n\n    const delta_t = event.timeStamp - timeStamp!\n    const kinematics = calculateAllKinematics(movement!, delta!, delta_t)\n\n    return {\n      values,\n      delta,\n      turns,\n      ...movementDetection,\n      ...kinematics,\n    }\n  }\n\n  protected mapStateValues(state: GestureState<T>): PartialGestureState<T> {\n    return { da: state.values, vdva: state.velocities } as PartialGestureState<T>\n  }\n}\n","import { TouchEvent, WheelEvent } from 'react'\nimport DistanceAngleRecognizer from './DistanceAngleRecognizer'\nimport Controller from '../Controller'\nimport { UseGestureEvent, IngKey, Vector2, WebKitGestureEvent } from '../types'\nimport { noop } from '../utils/utils'\nimport {\n  getGenericEventData,\n  getTwoTouchesEventData,\n  getWheelEventValues,\n  supportsGestureEvents,\n  getWebkitGestureEventValues,\n} from '../utils/event'\n\nexport default class PinchRecognizer extends DistanceAngleRecognizer<'pinch'> {\n  ingKey = 'pinching' as IngKey\n\n  constructor(controller: Controller, args: any[]) {\n    super('pinch', controller, args)\n  }\n\n  private pinchShouldStart = (event: UseGestureEvent) => {\n    const { touches } = getGenericEventData(event)\n    return this.enabled && touches === 2\n  }\n\n  onPinchStart = (event: UseGestureEvent<TouchEvent>) => {\n    if (!this.pinchShouldStart(event)) return\n\n    const { values, origin } = getTwoTouchesEventData(event)\n\n    this.updateSharedState(getGenericEventData(event))\n\n    const startState = {\n      ...this.getStartGestureState(values, event),\n      ...this.getGenericPayload(event, true),\n    }\n\n    this.updateGestureState({\n      ...startState,\n      ...this.getMovement(values, startState),\n      origin,\n      cancel: () => this.onCancel(),\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onPinchChange = (event: UseGestureEvent<TouchEvent>): void => {\n    const { canceled, timeStamp, _active } = this.state\n    if (canceled || !_active) return\n    const genericEventData = getGenericEventData(event)\n    if (genericEventData.touches !== 2 || event.timeStamp === timeStamp) return\n\n    this.updateSharedState(genericEventData)\n\n    const { values, origin } = getTwoTouchesEventData(event)\n    const kinematics = this.getKinematics(values, event)\n\n    this.updateGestureState({\n      ...this.getGenericPayload(event),\n      ...kinematics,\n      origin,\n      cancel: () => this.onCancel(),\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onPinchEnd = (event: UseGestureEvent): void => {\n    this.state._active = false\n    this.updateSharedState({ down: false, touches: 0 })\n\n    this.updateGestureState({\n      event,\n      ...this.getGenericPayload(event),\n      ...this.getMovement(this.state.values),\n    })\n    this.fireGestureHandler()\n  }\n\n  onCancel = (): void => {\n    this.state._active = false\n    this.updateGestureState({ canceled: true, cancel: noop })\n    this.updateSharedState({ down: false, touches: 0 })\n\n    requestAnimationFrame(() => this.fireGestureHandler())\n  }\n  /**\n   * PINCH WITH WEBKIT GESTURES\n   */\n\n  onGestureStart = (event: WebKitGestureEvent): void => {\n    if (!this.enabled) return\n    event.preventDefault()\n\n    const { values } = getWebkitGestureEventValues(event)\n\n    this.updateSharedState(getGenericEventData(event))\n\n    const startState = {\n      ...this.getStartGestureState(values, event),\n      ...this.getGenericPayload(event, true),\n    }\n\n    this.updateGestureState({\n      ...startState,\n      ...this.getMovement(values, startState),\n      cancel: () => this.onCancel(),\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onGestureChange = (event: WebKitGestureEvent): void => {\n    const { canceled, _active } = this.state\n    if (canceled || !_active) return\n\n    event.preventDefault()\n\n    const genericEventData = getGenericEventData(event)\n\n    this.updateSharedState(genericEventData)\n\n    const { values } = getWebkitGestureEventValues(event)\n    const kinematics = this.getKinematics(values, event)\n\n    this.updateGestureState({\n      ...this.getGenericPayload(event),\n      ...kinematics,\n      cancel: () => this.onCancel(),\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onGestureEnd = (event: WebKitGestureEvent): void => {\n    event.preventDefault()\n    this.state._active = false\n    this.updateSharedState({ down: false, touches: 0 })\n\n    this.updateGestureState({\n      event,\n      ...this.getGenericPayload(event),\n      ...this.getMovement(this.state.values),\n    })\n    this.fireGestureHandler()\n  }\n\n  updateTouchData = (event: UseGestureEvent<TouchEvent>): void => {\n    if (!this.enabled || event.touches.length !== 2) return\n    const { origin } = getTwoTouchesEventData(event)\n    this.state.origin = origin\n  }\n\n  /**\n   * PINCH WITH WHEEL\n   */\n  private wheelShouldRun = (event: UseGestureEvent<WheelEvent>) => {\n    return this.enabled && event.ctrlKey\n  }\n\n  private getWheelValuesFromEvent = (event: UseGestureEvent<WheelEvent>) => {\n    const {\n      values: [, delta_d],\n    } = getWheelEventValues(event)\n    const {\n      values: [prev_d, prev_a],\n    } = this.state\n    const d = prev_d - delta_d\n    const a = prev_a !== void 0 ? prev_a : 0\n\n    return {\n      values: [d, a] as Vector2,\n      origin: [event.clientX, event.clientY] as Vector2,\n      delta: [0, delta_d] as Vector2,\n    }\n  }\n\n  onWheel = (event: UseGestureEvent<WheelEvent>): void => {\n    if (!this.wheelShouldRun(event)) return\n    this.clearTimeout()\n    this.setTimeout(this.onWheelEnd)\n\n    if (!this.state._active) this.onWheelStart(event)\n    else this.onWheelChange(event)\n  }\n\n  onWheelStart = (event: UseGestureEvent<WheelEvent>): void => {\n    const { values, delta, origin } = this.getWheelValuesFromEvent(event)\n\n    if (!this.controller.config.eventOptions.passive) {\n      event.preventDefault()\n    } else if (process.env.NODE_ENV === 'development') {\n      console.warn(\n        'To support zoom on trackpads, try using the `domTarget` option and `config.event.passive` set to `false`. This message will only appear in development mode.'\n      )\n    }\n\n    this.updateSharedState(getGenericEventData(event))\n\n    const startState = {\n      ...this.getStartGestureState(values, event),\n      ...this.getGenericPayload(event, true),\n      initial: this.state.values,\n    }\n\n    this.updateGestureState({\n      ...startState,\n      ...this.getMovement(values, startState),\n      offset: values,\n      delta,\n      origin,\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onWheelChange = (event: UseGestureEvent<WheelEvent>): void => {\n    const genericEventData = getGenericEventData(event)\n\n    this.updateSharedState(genericEventData)\n\n    const { values, origin, delta } = this.getWheelValuesFromEvent(event)\n    const kinematics = this.getKinematics(values, event)\n\n    this.updateGestureState({\n      ...this.getGenericPayload(event),\n      ...kinematics,\n      origin,\n      delta,\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onWheelEnd = (): void => {\n    this.state._active = false\n    this.updateGestureState(this.getMovement(this.state.values))\n    this.fireGestureHandler()\n  }\n\n  addBindings(): void {\n    if (supportsGestureEvents()) {\n      this.controller.addBindings('onGestureStart', this.onGestureStart)\n      this.controller.addBindings('onGestureChange', this.onGestureChange)\n      this.controller.addBindings(['onGestureEnd', 'onTouchCancel'], this.onGestureEnd)\n      this.controller.addBindings(['onTouchStart', 'onTouchMove'], this.updateTouchData)\n    } else {\n      this.controller.addBindings('onTouchStart', this.onPinchStart)\n      this.controller.addBindings('onTouchMove', this.onPinchChange)\n      this.controller.addBindings(['onTouchEnd', 'onTouchCancel'], this.onPinchEnd)\n\n      this.controller.addBindings('onWheel', this.onWheel)\n    }\n  }\n}\n","import useRecognizers from './useRecognizers'\nimport PinchRecognizer from '../recognizers/PinchRecognizer'\nimport { Handler, InternalConfig, HookReturnType, UsePinchConfig } from '../types'\nimport { getInternalGenericOptions, getInternalDistanceAngleOptions } from '../utils/config'\n\n/**\n * @public\n *\n * Pinch hook.\n *\n * @param {Handler<'pinch'>} handler - the function fired every time the pinch gesture updates\n * @param {(Config | {})} [config={}] - the config object including generic options and pinch options\n * @returns {(...args: any[]) => HookReturnType<Config>}\n */\nexport function usePinch<Config extends UsePinchConfig>(\n  handler: Handler<'pinch'>,\n  config: Config | {} = {}\n): (...args: any[]) => HookReturnType<Config> {\n  const { domTarget, eventOptions, window, ...pinch } = config as UsePinchConfig\n\n  /**\n   * TODO: at the moment we recompute the config object at every render\n   * this could probably be optimized\n   */\n  const mergedConfig: InternalConfig = {\n    ...getInternalGenericOptions({\n      domTarget,\n      eventOptions,\n      window,\n    }),\n    pinch: getInternalDistanceAngleOptions(pinch),\n  }\n\n  return useRecognizers<Config>({ pinch: handler }, [PinchRecognizer], mergedConfig)\n}\n","import { WheelEvent } from 'react'\nimport CoordinatesRecognizer from './CoordinatesRecognizer'\nimport Controller from '../Controller'\nimport { UseGestureEvent, IngKey } from '../types'\nimport { getWheelEventValues, getGenericEventData } from '../utils/event'\nimport { addV, calculateDistance, calculateDirection } from '../utils/math'\n\nexport default class WheelRecognizer extends CoordinatesRecognizer<'wheel'> {\n  ingKey = 'wheeling' as IngKey\n\n  constructor(controller: Controller, args: any[]) {\n    super('wheel', controller, args)\n  }\n\n  private wheelShouldRun = (event: UseGestureEvent<WheelEvent>) => {\n    if (event.ctrlKey && 'pinch' in this.controller.handlers) return false\n    return this.enabled\n  }\n\n  private getValuesFromEvent = (event: UseGestureEvent<WheelEvent>) => {\n    const { values: prevValues } = this.state\n    const { values } = getWheelEventValues(event)\n    return { values: addV(values, prevValues) }\n  }\n\n  onWheel = (event: UseGestureEvent<WheelEvent>): void => {\n    if (!this.wheelShouldRun(event)) return\n    this.clearTimeout()\n    this.setTimeout(this.onWheelEnd)\n\n    if (!this.state._active) this.onWheelStart(event)\n    else this.onWheelChange(event)\n  }\n\n  onWheelStart = (event: UseGestureEvent<WheelEvent>): void => {\n    const { values } = this.getValuesFromEvent(event)\n\n    this.updateSharedState(getGenericEventData(event))\n\n    const startState = {\n      ...this.getStartGestureState(values, event),\n      ...this.getGenericPayload(event, true),\n      initial: this.state.values,\n    }\n\n    const movementDetection = this.getMovement(values, startState)\n    const delta = movementDetection.delta!\n\n    this.updateGestureState({\n      ...startState,\n      ...movementDetection,\n      distance: calculateDistance(delta),\n      direction: calculateDirection(delta),\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onWheelChange = (event: UseGestureEvent<WheelEvent>): void => {\n    const genericEventData = getGenericEventData(event)\n\n    this.updateSharedState(genericEventData)\n\n    const { values } = this.getValuesFromEvent(event)\n    const kinematics = this.getKinematics(values, event)\n\n    this.updateGestureState({\n      ...this.getGenericPayload(event),\n      ...kinematics,\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onWheelEnd = (): void => {\n    this.state._active = false\n    this.updateGestureState({ ...this.getMovement(this.state.values), velocities: [0, 0], velocity: 0 })\n    this.fireGestureHandler()\n  }\n\n  addBindings(): void {\n    this.controller.addBindings('onWheel', this.onWheel)\n  }\n}\n","import useRecognizers from './useRecognizers'\nimport WheelRecognizer from '../recognizers/WheelRecognizer'\nimport { Handler, InternalConfig, HookReturnType, UseWheelConfig } from '../types'\nimport { getInternalGenericOptions, getInternalCoordinatesOptions } from '../utils/config'\n\n/**\n * @public\n *\n * Wheel hook.\n *\n * @param {Handler<'wheel'>} handler - the function fired every time the wheel gesture updates\n * @param {(Config | {})} [config={}] - the config object including generic options and wheel options\n * @returns {(...args: any[]) => HookReturnType<Config>}\n */\nexport function useWheel<Config extends UseWheelConfig>(\n  handler: Handler<'wheel'>,\n  config: Config | {} = {}\n): (...args: any[]) => HookReturnType<Config> {\n  const { domTarget, eventOptions, window, ...wheel } = config as UseWheelConfig\n\n  /**\n   * TODO: at the moment we recompute the config object at every render\n   * this could probably be optimized\n   */\n  const mergedConfig: InternalConfig = {\n    ...getInternalGenericOptions({\n      domTarget,\n      eventOptions,\n      window,\n    }),\n    wheel: getInternalCoordinatesOptions(wheel),\n  }\n\n  return useRecognizers<Config>({ wheel: handler }, [WheelRecognizer], mergedConfig)\n}\n","import {} from 'react'\nimport CoordinatesRecognizer from './CoordinatesRecognizer'\nimport Controller from '../Controller'\nimport { UseGestureEvent, IngKey } from '../types'\nimport { getGenericEventData, getPointerEventValues } from '../utils/event'\n\nexport default class MoveRecognizer extends CoordinatesRecognizer<'move'> {\n  ingKey = 'moving' as IngKey\n\n  constructor(controller: Controller, args: any[]) {\n    super('move', controller, args)\n  }\n\n  private moveShouldRun = () => {\n    return this.enabled\n  }\n\n  onMove = (event: UseGestureEvent): void => {\n    if (!this.moveShouldRun()) return\n    this.clearTimeout()\n    this.setTimeout(this.onMoveEnd)\n\n    if (!this.state._active) this.onMoveStart(event)\n    else this.onMoveChange(event)\n  }\n\n  onMoveStart = (event: UseGestureEvent): void => {\n    const { values } = getPointerEventValues(event)\n\n    this.updateSharedState(getGenericEventData(event))\n\n    const startState = {\n      ...this.getStartGestureState(values, event),\n      ...this.getGenericPayload(event, true),\n    }\n\n    this.updateGestureState({\n      ...startState,\n      ...this.getMovement(values, startState),\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onMoveChange = (event: UseGestureEvent): void => {\n    const genericEventData = getGenericEventData(event)\n\n    this.updateSharedState(genericEventData)\n\n    const { values } = getPointerEventValues(event)\n    const kinematics = this.getKinematics(values, event)\n\n    this.updateGestureState({\n      ...this.getGenericPayload(event),\n      ...kinematics,\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onMoveEnd = (): void => {\n    this.state._active = false\n\n    this.updateGestureState({ ...this.getMovement(this.state.values), velocities: [0, 0], velocity: 0 })\n    this.fireGestureHandler()\n  }\n\n  onPointerEnter = (event: UseGestureEvent): void => {\n    this.controller.state.shared.hovering = true\n    if (!this.controller.config.enabled) return\n\n    if (this.controller.config.hover!.enabled) {\n      const { values } = getPointerEventValues(event)\n\n      const state = {\n        ...this.controller.state.shared,\n        ...this.state,\n        ...this.getGenericPayload(event, true),\n        values,\n        active: true,\n        hovering: true,\n      }\n\n      this.controller.handlers.hover!({ ...state, ...this.mapStateValues(state) })\n    }\n\n    if ('move' in this.controller.handlers) this.onMoveStart(event)\n  }\n\n  onPointerLeave = (event: UseGestureEvent): void => {\n    this.controller.state.shared.hovering = false\n\n    if (this.controller.config.hover!.enabled) {\n      const { values } = getPointerEventValues(event)\n\n      const state = {\n        ...this.controller.state.shared,\n        ...this.state,\n        ...this.getGenericPayload(event),\n        values,\n        active: false,\n      }\n\n      this.controller.handlers.hover!({ ...state, ...this.mapStateValues(state) })\n    }\n\n    if ('move' in this.controller.handlers) this.onMoveEnd()\n  }\n\n  addBindings(): void {\n    if (this.controller.config.pointer) {\n      if ('move' in this.controller.handlers) {\n        this.controller.addBindings('onPointerMove', this.onMove)\n      }\n      if ('hover' in this.controller.handlers) {\n        this.controller.addBindings('onPointerEnter', this.onPointerEnter)\n        this.controller.addBindings('onPointerLeave', this.onPointerLeave)\n      }\n    } else {\n      if ('move' in this.controller.handlers) {\n        this.controller.addBindings('onMouseMove', this.onMove)\n      }\n      if ('hover' in this.controller.handlers) {\n        this.controller.addBindings('onMouseEnter', this.onPointerEnter)\n        this.controller.addBindings('onMouseLeave', this.onPointerLeave)\n      }\n    }\n  }\n}\n","import useRecognizers from './useRecognizers'\nimport MoveRecognizer from '../recognizers/MoveRecognizer'\nimport { Handler, InternalConfig, HookReturnType, UseMoveConfig } from '../types'\nimport { getInternalGenericOptions, getInternalCoordinatesOptions } from '../utils/config'\n\n/**\n * @public\n *\n * Move hook.\n *\n * @param {Handler<'move'>} handler - the function fired every time the move gesture updates\n * @param {(Config | {})} [config={}] - the config object including generic options and move options\n * @returns {(...args: any[]) => HookReturnType<Config>}\n */\nexport function useMove<Config extends UseMoveConfig>(\n  handler: Handler<'move'>,\n  config: Config | {} = {}\n): (...args: any[]) => HookReturnType<Config> {\n  const { domTarget, eventOptions, window, ...move } = config as UseMoveConfig\n\n  /**\n   * TODO: at the moment we recompute the config object at every render\n   * this could probably be optimized\n   */\n  const mergedConfig: InternalConfig = {\n    ...getInternalGenericOptions({\n      domTarget,\n      eventOptions,\n      window,\n    }),\n    move: getInternalCoordinatesOptions(move),\n  }\n\n  return useRecognizers<Config>({ move: handler }, [MoveRecognizer], mergedConfig)\n}\n","import useRecognizers from './useRecognizers'\nimport MoveRecognizer from '../recognizers/MoveRecognizer'\nimport { Handler, InternalConfig, HookReturnType, UseHoverConfig } from '../types'\nimport { getInternalGenericOptions } from '../utils/config'\n\n/**\n * @public\n *\n * Hover hook.\n *\n * @param {Handler<'hover'>} handler - the function fired every time the hover gesture updates\n * @param {(Config | {})} [config={}] - the config object including generic options and hover options\n * @returns {(...args: any[]) => HookReturnType<Config>}\n */\nexport function useHover<Config extends UseHoverConfig>(\n  handler: Handler<'hover'>,\n  config: Config | {} = {}\n): (...args: any[]) => HookReturnType<Config> {\n  const { domTarget, eventOptions, window, ...hover } = config as UseHoverConfig\n\n  /**\n   * TODO: at the moment we recompute the config object at every render\n   * this could probably be optimized\n   */\n  const mergedConfig: InternalConfig = {\n    ...getInternalGenericOptions({\n      domTarget,\n      eventOptions,\n      window,\n    }),\n    hover: { enabled: true, ...hover },\n  }\n\n  return useRecognizers<Config>({ hover: handler }, [MoveRecognizer], mergedConfig)\n}\n","import {} from 'react'\nimport CoordinatesRecognizer from './CoordinatesRecognizer'\nimport Controller from '../Controller'\nimport { UseGestureEvent, IngKey } from '../types'\nimport { getGenericEventData, getScrollEventValues } from '../utils/event'\nimport { calculateDistance, calculateDirection } from '../utils/math'\n\nexport default class ScrollRecognizer extends CoordinatesRecognizer<'scroll'> {\n  ingKey = 'scrolling' as IngKey\n\n  constructor(controller: Controller, args: any[]) {\n    super('scroll', controller, args)\n  }\n\n  private scrollShouldRun = () => {\n    return this.enabled\n  }\n\n  onScroll = (event: UseGestureEvent): void => {\n    if (!this.scrollShouldRun()) return\n    this.clearTimeout()\n    this.setTimeout(this.onScrollEnd)\n\n    if (!this.state._active) this.onScrollStart(event)\n    else this.onScrollChange(event)\n  }\n\n  onScrollStart = (event: UseGestureEvent): void => {\n    const { values } = getScrollEventValues(event)\n\n    this.updateSharedState(getGenericEventData(event))\n\n    const startState = {\n      ...this.getStartGestureState(values, event),\n      ...this.getGenericPayload(event, true),\n      initial: this.state.values,\n    }\n\n    const movementDetection = this.getMovement(values, startState)\n    const delta = movementDetection.delta!\n\n    this.updateGestureState({\n      ...startState,\n      ...movementDetection,\n      distance: calculateDistance(delta),\n      direction: calculateDirection(delta),\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onScrollChange = (event: UseGestureEvent): void => {\n    const genericEventData = getGenericEventData(event)\n\n    this.updateSharedState(genericEventData)\n\n    const { values } = getScrollEventValues(event)\n    const kinematics = this.getKinematics(values, event)\n\n    this.updateGestureState({\n      ...this.getGenericPayload(event),\n      ...kinematics,\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onScrollEnd = (): void => {\n    this.state._active = false\n    this.updateGestureState({ ...this.getMovement(this.state.values), velocities: [0, 0], velocity: 0 })\n    this.fireGestureHandler()\n  }\n\n  addBindings(): void {\n    this.controller.addBindings('onScroll', this.onScroll)\n  }\n}\n","import useRecognizers from './useRecognizers'\nimport ScrollRecognizer from '../recognizers/ScrollRecognizer'\nimport { Handler, InternalConfig, HookReturnType, UseScrollConfig } from '../types'\nimport { getInternalGenericOptions, getInternalCoordinatesOptions } from '../utils/config'\n\n/**\n * @public\n *\n * Scroll hook.\n *\n * @param {Handler<'scroll'>} handler - the function fired every time the scroll gesture updates\n * @param {(Config | {})} [config={}] - the config object including generic options and scroll options\n * @returns {(...args: any[]) => HookReturnType<Config>}\n */\nexport function useScroll<Config extends UseScrollConfig>(\n  handler: Handler<'scroll'>,\n  config: Config | {} = {}\n): (...args: any[]) => HookReturnType<Config> {\n  const { domTarget, eventOptions, window, ...scroll } = config as UseScrollConfig\n\n  /**\n   * TODO: at the moment we recompute the config object at every render\n   * this could probably be optimized\n   */\n  const mergedConfig: InternalConfig = {\n    ...getInternalGenericOptions({\n      domTarget,\n      eventOptions,\n      window,\n    }),\n    scroll: getInternalCoordinatesOptions(scroll),\n  }\n\n  return useRecognizers<Config>({ scroll: handler }, [ScrollRecognizer], mergedConfig)\n}\n","import React from 'react'\nimport useRecognizers from './useRecognizers'\nimport DragRecognizer from '../recognizers/DragRecognizer'\nimport WheelRecognizer from '../recognizers/WheelRecognizer'\nimport MoveRecognizer from '../recognizers/MoveRecognizer'\nimport PinchRecognizer from '../recognizers/PinchRecognizer'\nimport ScrollRecognizer from '../recognizers/ScrollRecognizer'\nimport {\n  getInternalGenericOptions,\n  getInternalDragOptions,\n  getInternalCoordinatesOptions,\n  getInternalDistanceAngleOptions,\n} from '../utils/config'\nimport {\n  InternalConfig,\n  HandlerKey,\n  UserHandlersPartial,\n  InternalHandlers,\n  UserHandlers,\n  RecognizerClasses,\n  UseGestureConfig,\n  HookReturnType,\n} from '../types'\n\n/**\n * @public\n *\n * The most complete gesture hook, allowing support for multiple gestures.\n *\n * @param {UserHandlersPartial} handlers - an object with on[Gesture] keys containg gesture handlers\n * @param {UseGestureConfig} [config={}] - the full config object\n * @returns {(...args: any[]) => HookReturnType<Config>}\n */\nexport function useGesture<Config extends UseGestureConfig>(\n  handlers: UserHandlersPartial,\n  config: UseGestureConfig = {}\n): (...args: any[]) => HookReturnType<Config> {\n  /**\n   * If handlers contains {onDragStart, onDrag, onDragEnd, onMoveStart, onMove}\n   * actions will include 'onDrag' and 'onMove.\n   */\n  const [actions] = React.useState(() => new Set(Object.keys(handlers).map(k => k.replace(/End|Start/, ''))))\n\n  /**\n   * Here we compute the derived internal config based on the provided config object.\n   * We decompose the config into its generic and gesture options and compute each.\n   * TODO: this is currently done on every render!\n   */\n  const { drag, wheel, move, scroll, pinch, hover, ...restConfig } = config\n\n  const mergedConfig: InternalConfig = getInternalGenericOptions(restConfig)\n\n  const classes: RecognizerClasses = []\n  const internalHandlers: Partial<InternalHandlers> = {}\n\n  // will hold reference to native handlers such as onClick, onMouseDown, etc.\n  const _nativeHandlers = { ...handlers }\n\n  if (actions.has('onDrag')) {\n    classes.push(DragRecognizer)\n    internalHandlers.drag = includeStartEndHandlers(handlers, 'onDrag', _nativeHandlers)\n    mergedConfig.drag = getInternalDragOptions(drag)\n  }\n  if (actions.has('onWheel')) {\n    classes.push(WheelRecognizer)\n    internalHandlers.wheel = includeStartEndHandlers(handlers, 'onWheel', _nativeHandlers)\n    mergedConfig.wheel = getInternalCoordinatesOptions(wheel)\n  }\n  if (actions.has('onScroll')) {\n    classes.push(ScrollRecognizer)\n    internalHandlers.scroll = includeStartEndHandlers(handlers, 'onScroll', _nativeHandlers)\n    mergedConfig.scroll = getInternalCoordinatesOptions(scroll)\n  }\n  if (actions.has('onMove')) {\n    classes.push(MoveRecognizer)\n    internalHandlers.move = includeStartEndHandlers(handlers, 'onMove', _nativeHandlers)\n    mergedConfig.move = getInternalCoordinatesOptions(move)\n  }\n  if (actions.has('onPinch')) {\n    classes.push(PinchRecognizer)\n    internalHandlers.pinch = includeStartEndHandlers(handlers, 'onPinch', _nativeHandlers)\n    mergedConfig.pinch = getInternalDistanceAngleOptions(pinch)\n  }\n  if (actions.has('onHover')) {\n    if (!actions.has('onMove')) classes.push(MoveRecognizer)\n    internalHandlers.hover = handlers.onHover\n    mergedConfig.hover = { enabled: true, ...hover }\n    delete _nativeHandlers.onHover\n  }\n\n  return useRecognizers<Config>(internalHandlers, classes, mergedConfig, _nativeHandlers)\n}\n/**\n * @private\n *\n * This utility function will integrate start and end handlers into the regular\n * handler function by using first and last conditions.\n *\n * @param {UserHandlersPartial} handlers - the handlers function object\n * @param {HandlerKey} handlerKey - the key for which to integrate start and end handlers\n * @returns\n */\nfunction includeStartEndHandlers(\n  handlers: UserHandlersPartial,\n  handlerKey: HandlerKey,\n  _nativeHandlers: UserHandlersPartial\n) {\n  const startKey = (handlerKey + 'Start') as keyof UserHandlers\n  const endKey = (handlerKey + 'End') as keyof UserHandlers\n\n  delete _nativeHandlers[handlerKey]\n  delete _nativeHandlers[startKey]\n  delete _nativeHandlers[endKey]\n\n  const fn = (state: any) => {\n    let memo: any = undefined\n    if (state.first && startKey in handlers) handlers[startKey]!(state)\n    if (handlerKey in handlers) memo = handlers[handlerKey]!(state)\n    if (state.last && endKey in handlers) handlers[endKey]!(state)\n    return memo\n  }\n  return fn\n}\n"]},"metadata":{},"sourceType":"module"}